[["index.html", "Introdução à Análise de Dados em R utilizando Tidyverse Bem-vindo! Por que R ? Organização do Curso Sobre o autor", " Introdução à Análise de Dados em R utilizando Tidyverse Allan Vieira de Castro Quadros 2023-10-27 Bem-vindo! Este é o repositório do livro texto do curso de Introdução à Análise de Dados em R utilizando Tidyverse. Para reproduzir os códigos presentes no livro, você precisa de uma versão recente do R e pacotes atualizados. Ao início de cada seção, você será apresentado aos pacotes necessários para executar os códigos referentes àquele assunto. Todos os datasets e outros arquivos de dados a serem utilizados durante os Módulos, estão disponíveis no repositório Git deste livro, na pasta datasets: https://github.com/allanvc/book_IADR-T/tree/master/datasets Também recomenda-se a utilização da versão mais recente do Ambiente Integrado de Desenvolvimento (IDE) RStudio. Por que R ? A linguagem de programação R é conhecida por ter uma curva de aprendizagem relativamente lenta, mas, uma vez que o aluno entende a estrutura básica de objetos que compõe a linguagem, o aprendizado passa a ser exponencial. Figure 0.1: Curva de Aprendizagem R R é relativamente diferente das demais linguagens de programação porque foi desenvolvida por Estatísticos para Estatísticos. Ela não foi pensada para ser a mais eficiente das linguagens em termos de rapidez, mas sim para tornar mais fácil a vida de quem analisa dados. Minha experiência com outras linguagens de programação levam me a afirmar que isto é verdade: não há linguagem mais adequada para realizar análise de dados do que R. Preferêncas individuais e outras conveniências podem levar a escolha de uma ou outra linguagem, mas não há como não concordar com o fato de que R possui as melhores ferramentas de Data Wrangling (preparação de dados), geração de gráficos, geração de relatórios e reproducibilidade. Além disso, R é mundialmente reconhecido por sua comunidade extremamente ativa e inclusiva. É a linguagen preferida na academia, tendo em vista que novas técnicas matemáticas, estatísticas, e/ou computacionais são implementadas primeiro em R. É também uma das liguagens mais usadas na indústria para Ciência de Dados, juntamente com Python. Por esses motivos e por ser uma linguagem open source, dotada de um poderoso ambiente de gerenciamento de pacotes, a disseminação do uso de R em seus 20 anos de história foi extremamente rápida e acabou por relegar ao segundo plano ambientes de análise de dados e linguagens como SAS, SPSS e Stata. No R, você encontra pacotes para as mais diversas finalidades: desde pacotes que geram provas a partir de um banco de questões, passando por pacotes de preparação de dados, otimização matemática, Machine Learning, até pacotes para análise de áudio, criação de aplicativos, leitura e envio de emails. Hoje em dia, há diversos ambientes e linguagens utilizadas para Análise de Dados, como Python, Julia, Scala, SAS, etc. No entanto, nenhuma delas fornece a combinação de um excelente ecositema de gerenciamento de pacotes, capacidades estatísticas, opções de visualização e um poderoso IDE (Integrated Development Environment) - tudo implementado pela comunidade R. Por todas essas características, os benefícios ao aprender a linguagem R são realmente consideráveis. Organização do Curso Este curso é dividido em 5 Módulos. O Módulo 1 busca ambientar o aluno com os conceitos básicos da linguagem, passando pelo histórico, funcionalidades básicas e a estrutura dos objetos mais importantes no R. Os Módulos 2 e 3 são divididos sempre em 3 partes: leitura de dados, manipulação de dados e visualização. A cada Módulo, são apresentados novos pacotes para estas funcionalidades, com um nível um pouco mais profundo de especialização em relação ao módulo anterior. O Módulo 4 inicia-se com foco na manipulação de strings e expressões regulares (REGEX) e finaliza aprsentando técnicas de produção de relatórios e reproducibilidade no R. Por fim, o Módulo 5 apresenta um ferramental de análise econômica regional, interessante aos Pesquisadores do IPEA, público-alvo deste curso. Sobre o autor Allan V. C. Quadros é autor dos pacotes R, emstreeR, mRpostman e onlineretail; e aualmente realiza o seu Ph.D. em Estatística pela Kansas State University (EUA). Sua experiência profissional inclui o cargo de Lead Data Scientist no Núcleo de Métodos Quantitativos e Assessor de Gestão Estratégica e Governança – ambos no Fundo Nacional de Desenvolvimento da Educação (FNDE); Professor Universitário; Assessor de Investimentos; e 1º Tenente de Infantaria do Exército Brasileiro. Seus principais interesses acadêmicos são Computational Statistics, Mathematical Finance, Otimização, Processos Estocásticos e Astroestatística. Ultimamente, tem atuado no desenvolvimento de pacotes R e em pesquisas acadêmicas no âmbito das disciplinas de estatística, computação e data science. Atua ainda na confecção de ferramentas de arbitragem estatística utilizadas como estratégias de investimento no mercado financeiro utilizando R e Python. Mais informações sobre o autor podem ser encontradas em: https://allanvc.github.io. "],["m1.html", " 1 Módulo I 1.1 Primeiros Passos 1.2 Estrutura de Objetos da Linguagem R", " 1 Módulo I 1.1 Primeiros Passos 1.1.1 Breve Histórico R é uma linguagem e um ambiente para programação estatística que roda em diversas plataformas *NIX, no Windows e MacOS (R-project.org), podendo ser baixado e distribuído gratuitamente de acordo com a General Public license (GPL). A origem do nome R remonta à linguagem S, desenvolvida por John Chambers entre 1975 e 76 na Bell Labs (antiga AT&amp;T e atual Lucent Technologies) – mesmo local de origem de importantes inovações na área de computação, como o sistema operacional UNIX, a linguagem de programação C, os transístores, dentre outras. Em contraponto à implementação comercial da linguagem S – o S-PLUS, Ross Ihaka e Robert Gentleman, do departamento de Estatística de Auckland - Nova Zelândia criaram, em 1995, o R como uma alternativa livre e gratuita à linguagem S. O próprio nome R vem de um jogo com a linguagem S e as iniciais dos nomes dos autores, Ross e Robert. Figure 1.1: Local de Nascimento do R indicado com o pacote leaflet. Clique no pin azul 1.1.2 Instalação do R A instalação do ambiente R é fácil de ser realizada em qualquer sistema operacional. No windows, os passos são: 1 Acesse o site https://www.r-project.org/. 2 Clique em download R ou CRAN mirror. 3 Escolha o repositório (Comprehensive R Archive Network - CRAN) de preferência. 4 Clique em Download R for Windows. 5 Clique em base. 6 Baixe o executável de instalação, clicando em Download R X.X.X for Windows. 7 Execute o arquivo baixado para a instalação do software. A janela default do R no Windows é bastante simplória. Pode-se observar que é dividida em uma janela maior, chamada de R GUI (R Graphical User Interface) – ou seja, a interface gráfica do R; e uma janela R Console. Nesta última janela, ao se iniciar o R, tem-se uma descrição sobre a versão utilizada e algumas dicas sobre a linguagem. O sinal &gt; indica a linha de comando ou prompt, que é onde digitam-se os comandos a serem rodados pelo interpretador. Interface Gráfica do R no Windows Aqui, cabe uma distinção entre a linguagem R e algumas outras linguagens de programação: a linguagem R é uma linguagem interpretada, ou seja, a execução do código ocorre juntamente com a análise do código, como se fosse on-demand. Digita-se o código, dá-se o comando de execução e imediatamente o interpretador reúne os comandos, os traduz para linguagem de máquina (ou linguagem de baixo nível) e os transfere para o processador para execução. Outro exemplo de linguagem interpretada seria Python. Nas linguagens compiladas, a análise de código ocorre em apenas uma fase – compilação – quando se analisa os dados e transforma-se o código-fonte em código-alvo. O código-alvo geralmente fica separado, em um arquivo executável, que será executado em um momento posterior. 1.1.3 Instalação do RStudio Tendo em vista que a interface gráfica original do R é bastante modesta, existem diversos Integrated Development Environment (IDEs) que reúnem várias ferramentas de apoio à programação e análise de dados, com o objetivo de facilitar a vida de seus usuários. O IDE mais utilizado para a linguagem R é o RStudio. Veja, a seguir, passos para instalação do RStudio no Windows: Acesse o site https://www.rstudio.com/. Clique em DOWNLOAD. Escolha a versão FREE e clique em DOWNLOAD RStudio for Windows. Como se vê, a interface do gráfica do RStudio é mais “amigável” do que a default do R. A janela está dividida em três partes: uma para Console, outra para Environment, History e Connections e mais outra para Files, Plots, Packages, Help e Viewer. Ao painel de Environment, History e Connections podem ser acrescentadas outras abas, dependendo do tipo de trabalho que você está desenvolvendo no R, como por exemplo a aba Presentations, quando se está produzindo slides ou a aba Build quando está construindo e testando um pacote. Os nomes em geral são auto-explicativos, mas falaremos mais sobre eles nos próximos módulos. Interface do RStudio 1.1.4 Instalação do RTools no Windows Mais adiante, veremos como instalar pacotes no R, que nada mais são que módulos que podem ser adicionados à sua intalação padrão do R. Acontece que alguns desses módulos possuem partes escritas em outras linguagens, como C++ e Fortran, que são linguagens compiladas. Por default, o Windows não vem com compiladores que possam executar esta tarefa, diferentemente de Linux e Mac. Para contornar este problema no Windows, instalamos o RTools. O aplicativo Windows RTools, também desenvolvido pela R Foundation, contém os compiladores e outras ferramentas necessárias para instalar os pacotes R que necessitam de compilação. A instalação é bem simples: Acesse https://cran.r-project.org/bin/windows/Rtools/ Baixe o executável recomendado, geralmente marcado na cor verde e com a observação recommended; Execute o aplicativo mantendo as opções-padrão sugeridas durante a instalação. 1.1.5 Funcionalidades Básicas do R e do RStudio 1.1.5.1 R como Calculadora A forma mais básica de se utilizar o R é como uma calculadora. As operações aritméticas básicas são executadas com os seguintes operadores no R: Operador Operação + adição - subtração * multiplicação / divisão ^ ou ** exponenciação x%%y módulo resto x%/%y quociente inteiro Vejamos alguns exemplos, digitando em nosso console, logo ao lado de &gt;, as seguintes operações: 2+1 ## [1] 3 4-2 ## [1] 2 2*3 ## [1] 6 3/3 ## [1] 1 3^2 ## [1] 9 3**2 ## [1] 9 5%%2 ## [1] 1 5%/%2 ## [1] 2 Perceba que ao lado de todas as repostas, apareceu [1]. Os colchetes e o número 1 dentro indicam que naquela linha está o primeiro elemento do objeto resultante. Isso acontece porque o R, sempre que possível, trabalha de forma vetorizada. O valor dentro de [ ] indica a posição dentro do vetor de resposta do número logo a direita (resultado). Como em cada operação, a resposta é única, todos os valores estavam localizados na primeira posição do nosso vetor de resposta. Isso vai ser bastante útil quando você quiser, por exemplo, aplicar uma operação matemática ou qualquer outra transformação a todas as entradas de uma coluna em uma tabela e imprimir o resultado no console. No output, o R vai quebrar o resultado em algumas linhas e esses números entre colchetes nos ajudarão a identificar a qual posição do vetor de resposta pertence o primeiro número de cada linha na saída impressa no console. Teste por exemplo: 1:100 * 2 ## [1] 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 ## [27] 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 102 104 ## [53] 106 108 110 112 114 116 118 120 122 124 126 128 130 132 134 136 138 140 142 144 146 148 150 152 154 156 ## [79] 158 160 162 164 166 168 170 172 174 176 178 180 182 184 186 188 190 192 194 196 198 200 No nosso exemplo, o R optou por quebrar a multiplicação dos 100 números em grupos de 17 números nas 4 primeiras linhas e num grupo de 15 valores na última. Na primeira linha de nosso output, 2 é o elemento na posição 1 ([1]) do vetor de resposta; na segunda linha, o número 36 é o elemento que se refere à posição 18 ([18]) do vetor de resposta e assim por diante, até a última linha que começa no elemento de posição 86. 1.1.5.1.1 Priorização e Hierarquia de Operações Assim como no MS Excel, os parênteses também serão muito úteis para realizar tanto operações aritméticas, quanto comparações e execução sequencial de funções no R. Com eles, poderemos indicar a “prioridade” ou a ordem em que os cálculos/computações devem ser efetuados. Teste o exemplo abaixo: ((1007+1)/8)^2 ## [1] 15876 Note que a operação é feita de dentro para fora. Primeiro o interpretador executa (1007+1), depois divide este resultado por 8 (/8), para só então elevar tudo ao quadrado (^2). Sem os parênteses, o resultado seria bem diferente: 1007+1/8^2 ## [1] 1007.016 1.1.5.2 Operadores Lógicos Você pode, ainda, realizar comparações lógicas no R. Abaixo estão relacionados alguns dos operadores lógicos que serão importantes nos primeiros módulos do curso. Outros serão apresentados nos demais módulos: Operador Operação &gt; maior que &gt;= maior ou igual a &lt; menor que &lt;= menor ou igual a == igual a != diferente de x&amp;&amp;y x E y x||y x OU y Vejamos alguns exemplos: 2 &gt; 1 ## [1] TRUE 1009 &gt;= 1009 ## [1] TRUE 3 &lt; 0.7 ## [1] FALSE 3 &lt;= 3.0001 ## [1] TRUE 7 == 5 ## [1] FALSE 4353.789 == 4353.7891 ## [1] FALSE 8 != 13 ## [1] TRUE 4353.789 != 4353.7891 ## [1] TRUE 2 == 2 &amp;&amp; 7 != 5 ## [1] TRUE (2 == 2) &amp;&amp; (7 != 5) ## [1] TRUE (2 == 3) || (7 &lt;= 5) ## [1] FALSE 4353.789 != 4353.7891 || 7 &gt;= 0.7 ## [1] TRUE Note que as respostas são, nestes exemplos, sempre um vetor lógico: TRUE ou FALSE. Mais à frente, veremos os demais tipos de vetores existentes no R. 1.1.5.3 Guardando seus códigos em um script No RStudio, você pode acrescentar um pequeno painel, que facilitará ainda mais o seu trabalho. Trata-se do source pane, um painel onde você pode criar scripts para armazenar várias linhas de código, de modo a excutá-las de uma única vez ou linha-a-linha. Caso queira guardar as contas e comparações lógicas que fez anteriormente em um arquivo de modo a poder executá-las posteriormente, você poderá fazê-lo por meio de um script. Na janela de script, você consegue manter uma trilha de todos os comandos utilizados. Isto é importante, pois otimiza o uso do R ao permitir rodar os mesmos códigos para diferentes arquivos e diferentes ocasiões, em vez de termos que refazer toda a programação a cada vez que mudarem nossos dados de entrada. Você pode abrir várias janelas de script, uma ao lado da outra, e navegar entre elas, como se faz com as abas de um browser. Neste curso, faremos todas as aulas e exercícios utilizando os arquivos de script. Para acrescentar a janela de script (source pane), basta criar um novo arquivo, clicando em , logo abaixo de File, e em seguida em . Nossa janela do RStudio deve ficar conforme a figura a seguir. Vamos acrescentar todas as linhas de códigos que executamos anteriormente ao nosso script recém criado. DICA: Você pode inserir comentários em seus scripts como uma forma de documentar os passos de seu trabalho para refrência futura. No R, os comentários são incluídos com o caractere #. Para salvar o arquivo de script, basta pressionar Ctrl+S ou clicar no disquete único na barra de menus. Esse arquivo será salvo com extensão .R, indicando que se trata de um arquivo com códigos da linguagem R. DICA: Sugerimos que você crie e salve um ou mais scripts a cada aula/seção. Isso o ajudará a organizar seu material e recuperar conceitos e exemplos importantes durante e após o curso. Você pode executar todas as linhas de um script ou optar por executar apenas algumas poucas linhas ou trechos específicos desse código. Selecione o trecho que deseja executar e pressione Ctrl+Enter. Você verá, no console (janela abaixo do script), seu código sendo executado. Uma alternativa ao Ctrl+Enter é selecionar o trecho ou linha(s) e clicar em . Na maioria das vezes, nosso código pode levar um tempo considerável para ser executado completamente. Para saber se o interpretador ainda está ocupado executando o seu código, basta olhar para o canto direito do painel Console. Se você ver o símbolo , o interpretador ainda está ocupado executando a última sequência de comandos. O símbolo \"&gt;\" também não aparecerá livre no console. Você pode tentar parar a execução clicando no ícone de stop. No entanto, nem sempre será possível interrompê-la. Tente gerar uma distribuição normal com 100 milhões de entradas: rnorm(1:100000000) DICA: Pode acontecer ainda de você olhar para o console e não ver o símbolo &gt;, sem que tenha aparecido o ícone de stop no canto direito do painel. Isso geralmente acontece quando esquecemos de fechar algum parenteses, chave ou colchete aberto no início de uma linha de código. Faça um teste: ((1007+1)/8^2 O console ficará esperando você completar o código. Você tem duas opções, acrescentar o parênteses faltante (caso seja possível) diretamente no console, ou pressionar Esc, consertar o código e executá-lo novamente. 1.1.5.4 Aba Environment Todos os objetos que forem criados na sua sessão do R/RStudio serão automaticamente armazenados no que chamamos de Global Environment, representado pela aba Environment no RStudio. Aba Environment Note que até o momento, nosso Environment encontra-se vazio. Isso porque ainda não “guardamos” nenhum objeto ou resultados das operações que realizamos anteriormente. 1.1.5.4.1 Atribuição de objetos no R Para criarmos um objeto no R, seja para armazenar um valor específico ou o resultado de uma operação, utilizamos o sinal de atribuição característico do R &lt;-, i.e. a &lt;- b (lê-se a recebe o valor de b). Pode-se utilizar ainda o sentido contrário: b -&gt; a (a recebe o valor de b), ou ainda o sinal de igual =. Essas alternativas são menos convencionais. Sugerimos a utilização de a &lt;- b para que não se confunda a criação de objetos com a passagem de parâmetros em argumentos de funções mais a frente. Para criar um objeto/variável x que contém o valor 2, execute: # x recebe 2 x &lt;- 2 # para ver o valor de x: x ## [1] 2 DICA: O atalho para o operador de atribuição &lt;- é Alt+-. Note agora que nossa aba Environment não está mais vazia: Agora vamos salvar os resultados de algumas operações aritiméticas e de comparações lógicas: out1 &lt;- 789/34.5 out2 &lt;- 3^2 out3 &lt;- out1 &gt; out2 Vejamos como ficou nosso Environment com os novos objetos criados: O R é bastante liberal no que se refere a sua política de nomes de objetos. As proibições são apenas as seguintes: um nome não pode iniciar com algarismo, ex: 1out &lt;- 2; um nome não pode conter apenas algarismos, ex: 01 &lt;- 2; um nome não pode conter caracteres especiais, a não ser . ou _, ex: out#01 &lt;- 2 um nome não pode ser idêntico a uma palavra utilizada como token da linguagem R, ex: TRUE &lt;- 2; for &lt;- 2, etc. DICA: A linguagem R é case sensitive, ou seja, ela faz distinção entre letras maiúsculas e minúsculas de um nome. Portanto Nome_do_Objeto != nome_do_objeto! 1.1.5.5 Salvando os objetos do Environment E se você quiser salvar esses objetos criados na sua sessão de R, para continuar trabalhando neles posteriormente? É possível fazê-lo e é simples. Para salvar todos os objetos do seu Environment, clique em Session e Save Workspace As... no RStudio. Será salvo um arquivo com extensão .RData com o nome e caminho que você especificar. Uma alternativa também seria: save.image(&quot;C:\\\\caminho_para_pasta_de_preferencia\\\\meu_workspace.RData&quot;) # ou save.image(&quot;C:/caminho_para_pasta_de_preferencia/meu_workspace.RData&quot;) DICA: A barra invertida \\ tem uma função especial no R, ela funciona como um caractere de escape, o quê veremos mais a fundo em sessões futuras. Portanto, para que uma barra invertida deixe de ter sua função especial, precisamos “escapá-la” com outra barra invertida. Por isso, usamos duas barras em endereços do Windows. Uma forma de contornar isso é usar barras normais, como no Linux. Mesmo no Windows, o R saberá que você está especificando um caminho Windows. Para carregar o arquivo salvo em sessões futuras, você tem novamente duas alternativas. A primeira é clicar em Session e Load Workspace... no RStudio. A segunda é: load(&quot;C:\\\\caminho_para_pasta_de_preferencia\\\\meu_workspace.RData&quot;) Se você quiser salvar elementos específicos e não todo o environment, você pode fazê-lo da seguinte forma: save(out1, out2, file=&quot;C:\\\\caminho_para_pasta_de_preferencia\\\\meus_objetos.RData&quot;) Para carregar esses objetos, você também poderá usar a função load(). DICA: Para salvar e carregar um único elemento, como por exemplo um dataset (tabela) que foi trabalhado, mas que deverá ainda ser carregado em uma nova sessão, você pode usar as funções saveRDS() e readRDS(). Trata-se d eum formato mais otimizado para salvar grandes objetos. 1.1.6 Estrutura da linguagem R R pode ser considerado uma linguagem de programação funcional, uma vez que a maioria dos procedimentos e rotinas são realizadas por meio de funções que recebem alguns argumentos como input, executam algumas ações sobre esses argumentos e retornam um output. Grosso modo, o uso de funções se dá da seguinte forma: nome_da_funcao(argumento1 = valor1, argumento2 = valor2, ...) Embora os operadores aritiméticos e lógicos vistos anteriormente não se enquadrem na estrutura funcional descrita acima, acabam por operar internamente como funções. Como você verá mais à frente, qualquer usuário pode criar uma função no R e não somente utilizar as disponibilizadas pela distribuição default da linguagem. DICA: Não precisamos utilizar sempre o formato nome_argumento=valor dentro das funções, pois o R é inteligente o suficiente para fazer o matching dos argumentos pela posição em que são passados (nome_da_funcao(valor1, valor2)) ou mesmo pelas letras iniciais do argumento informado. Vejamos alguns exemplos de funções que executam oeprações matemáticas e que já vem de fábrica no base R (distribuição básica do R): DICA: O RStudio possui a funcionalidade de autocompletar as palvras que você digita com os objetos criados durante sua sessão R ou já existentes na memória. Quando for digitar as funções abaixo, faça um teste digitando as primeiras duas letras de cada função e pressiona TAB. # raiz quadrada sqrt(81) ## [1] 9 # juntando com priorização de operações sqrt((3*3)^2) ## [1] 9 ## produtório prod(2,2) # 2x2 ## [1] 4 prod(2,3,5,7,8) # 2x3x5x7x8 ## [1] 1680 ## logaritmo # log de 3 na base e log(3) # log natural ## [1] 1.098612 # log de 3 na base 10 log(3,10) ## [1] 0.4771213 # log3 na base 10 log10(3) ## [1] 0.4771213 # abs = modulo, |3 - 9| abs(3-9) ## [1] 6 # fatorial # 4 fatorial factorial(4) ## [1] 24 1.1.6.1 Pacotes no R Um dos motivos do grande sucesso da linguagem R deve-se ao fato de que qualquer usuário pode desenvolver uma “suíte” contendo diversas funções, para executar uma ou várias tarefas. Esse conjunto ou suíte de funções pode ser disponibilizado na forma de um pacote, o qual outros usuários poderão instalar e também dele usufruir. Após cumprir uma série de exigentes requisitos, esses pacotes geralmente são disponibilizados no Comprehensive R Archive Network (CRAN). O CRAN possui uma política bastante séria de revisão de pacotes. Para que um pacote R possa compor o repositório do CRAN, deve atender a uma série de exigências e ser aprovado em diversos testes focados essencialmente nos seguintes fatores: segurança para o usuário; funcionamento sem erros em pelo menos dois sistemas operacionais; documentação densa (inclusive com citações bibliográficas) sobre as funcionalidades do pacote. Tudo isso faz com que os pacotes disponibilizados no CRAN sejam bastante confiáveis, transformando-se assim na fonte oficial de distribuição de pacotes da linguagem. Se você quiser saber o número de pacotes disponíveis no CRAN hoje, execute: dim(available.packages(contrib.url(getOption(&quot;repos&quot;)), filters=list()))[1] Em números de março de 2020, como você deve ter notado, temos mais de 15 mil pacotes no CRAN para as mais diversas finalidades. Para saber os tipos de pacotes existentes no repositório, recomenda-se uma visita ao Task Views do CRAN. Há pacotes de Econometria, Análise Econômica Regional, Estatítica, Clusterização, Ensaios Clínicos, Séries Temporais, Otimização, Tratamento de Dados, Aprendizagem de Máquina e muitos outros. 1.1.6.2 Instalação de pacotes Para instalar pacotes disponíveis no CRAN, deve-se utilizar a função install.packages(\"nome_do_pacote\"), passando-se o nome do pacote desejado entre aspas como argumento da função. Vamos testar essa funcionalidade instalando o pacote REAT - Regional Economic Analysis Toolbox, que é um pacote que você provavelmente utilizará bastante em suas análises no IPEA: install.packages(&quot;REAT&quot;) Se o pacote foi corretamente instalado, você deve ver algo semelhante a seguinte mensagem no console: package ‘REAT’ successfully unpacked and MD5 sums checked The downloaded binary packages are in C:\\Users\\...\\...\\...\\...\\...\\downloaded_packages &gt; Não se assuste caso outros pacotes também tenham sido instalados. Isso é muito comum, uma vez que alguns pacotes podem recorrer a funções presentes em outras bibliotecas. Para carregar ou anexar o pacote à sua sessão no R, de modo que você possa utilizar as funções disponíveis nele, empregamos a função library(nome_do_pacote) ou require(nome_do_pacote). Neste caso, o nome do pacote pode vir com ou sem aspas. library(REAT) Se você não quiser carregar um pacote completamente em sua sessão do R, porque vai apenas utilizar uma função específica, ao invés de library(), você pode usar o formato nome_do_pacote::nome_dafunção(parâmetro). 1.1.6.3 Outras fontes de pacotes Cabe destacar que a versão básica instalada do R, que chamamos de base R, já vem com alguns pacotes instalados, como por exemplo os pacotes stats, MASS, foreign, graphics, o próprio base, dentre outros. Para listar todos os pacotes instalados em sua máquina, execute: installed.packages() Embora o CRAN seja o repositório oficial de pacotes R, é importante mencionar a existência de outras fontes também importantes para obtenção de pacotes. A primeira das fontes alternativas é o Bioconductor, que é um projeto open source de desenvolvimento de softwares relacionados à análise e compreensão de dados genômicos gerados em experimentos de laboratório relacionados a biologia molecular. É, portanto, um importante repositório de pacotes para quem trabalha com Bioinformatics ou Biostatistics. A segunda fonte seria o Github que é um sistema para gerenciamento e versionamento de código. Qualquer pessoa pode criar uma conta no github e começar a compartilhar seus códigos, os quais poderão ser acessados e modificados/melhorados (com o consenso do autor original). No caso do R, os pacotes normalmente possuem uma versão estável no CRAN e uma versão de desenvolvimento no Github, onde os autores e demais colaboradores estão trabalhando no melhoramento e resolução de bugs dos pacotes. Uma vez que a versão do GitHub esteja estável e pronta para lançamento, o autor pode enviá-la ao CRAN. Acesse o repositório do meu pacote emstreeR no Github: https://www.github.com/allanvc/emstreeR. Você pode instalar pacotes no R a partir de suas versões no Github. Isso é relativamente comum e ocorre quando uma nova funcionalidade que você deseja testar foi implementada somente na versão de desenvolvimento do pacote e ainda não se encontra disponível no CRAN. Para instalar pacotes a partir de suas versões no Github, você precisa de outro pacote antes, o devtools. Vamos instalar a versão de desenvolvimento do pacote emstreeR: install.packages(&quot;devtools&quot;) # caso não o tenha instalado em sua máquina # alternativa 1 devtools::install_github(repo=&quot;allanvc/emstreeR&quot;) # ou # alternativa 2 library(devtools) install_github(repo=&quot;allanvc/emstreeR&quot;) Note que passamos o caminho do repositório no argumento repo. 1.1.7 Como obter ajuda Essa talvez seja a parte mais importante de todo o material. Saber como e onde buscar ajuda pode significar gastar apenas alguns minutos ao invés de horas ou mesmo dias na resolução de um problema envolvendo análise de dados e programação. Ao longo deste curso e ao empregar R em uma atividade de trabalho, vocês vão se deparar com diversas dúvidas envolvendo lógica de programação, análise de dados, ou mesmo buscando sabe se existe algum pacote já implementado que realize a tarefa que vocês precisam. 1.1.7.1 O Help do R O primeiro local para se buscar ajuda sobre algo relacionado ao R, normalmente está dentro do próprio R ou RStudio. Conforme meniconamos na seção @ref(#pkg), a política do CRAN exige que os pacotes estejam muito bem documentados. E isso ajuda muito aos usuários e desenvolvedores. Além da documentação do base Re dos demais pacotes que já acompanham a instalação padrão, ao instalar um novo pacote, a documentação desta nova biblioteca passa a compor o help do R instalado em sua máquina. Então, quando queremos entender uma função, ou seja, conhecer seus parâmetros de entrada, o que ela faz e o que retorna, recomenda-se utilizar o help do próprio R. No painel direito inferior, você encontra uma série de abas, sendo que a 3ª delas é aba que exibe o material de ajuda. Você pode fazer as buscas utilizando o campo de pesquisa da própria aba, ou por meio de comandos inseridos no console. Painel de ajuda do R/Rstudio Um exemplo: imagine que você gostaria de saber se o R possui alguma função que calcula o logaritmo (base \\(e\\)) de um número. Para isso, temos a função help.search(), que recebe como parâmetro (“entre aspas”) o tópico sobre o qual você deseja pesquisar. Toda a ajuda do R está em inglês; por isso, se você quer encontrar algo relacionado à logaritmo, deve executar o comando help.search(\"logarithm\") ou ??logrithm. Vejamos: # alternativa 1 help.search(&quot;logarithm&quot;) # ou # alternativa 2 ??logarithm Na aba Help do RStudio aparecerá o resultado dos pacotes e as respectivas funções que contém as palavras que você buscou. Nesse caso, portanto, caso, temos a função log() do pacote base para calcular logaritmos. Veja: Resultados de busca Se você já sabe exatamente o nome da função ou objeto do R sobre o qual deseja obter ajuda, pode utilizar também help(\"palavra\") ou ?palavra. # alternativa 1 help(&quot;log&quot;) # ou # alternativa 2 ??log Documentação da função log() Geralmente, os tópicos mais importantes dos arquivos de ajuda são Description, Usage, Arguments e Examples. O primeiro mostra o que a função faz, o segundo como a função deve ser usada, o terceiro quais argumentos ela recebe e, no quarto, você encontra exemplos de como ela funciona. Value também pode ser interessante, pois informa qual tipo de objeto a função retorna. 1.1.7.1.1 Vignettes Mais a frente, veremos como instalar novos pacotes no R. Esses pacotes são como módulos adicionais que permitem ao usuário realizar mais operações e atividades na linguagem. Muitos desses pacotes trazem consigo, além da documentação básica, verdadeiros tutoriais sobre como utilizar o pacote em si ou funções específicas desses pacotes. São muito mais detalhados que a simples documentação do Help do pacote ou de uma função. Enquanto alguns não fornecem qualquer vignette, outros podem trazem mais de uma vignette. Caso você queira verificar utilize: vignette(&quot;nome_do_pacote&quot;) 1.1.7.2 Ajuda via Internet R é bastante conhecido por sua comunidade extremamente ativa. Muitas vezes, ao analisar dados, surgem problemas que não são passíveis de solução apenas com a documentação interna da linguagem. Nesses casos, é necessário recorrer à experiência de outros usuários que tenham vivenciado o problema e que possam dar dicas de como ao ponto desejado. Nos 20 anos do R, vai ser difícil não encontrar alguém que vivenciou o mesmo problema que você. Nesse ponto a internet é nossa melhor amiga e não é vergonha nenhuma procurar ajuda lá. Dos mais inexperientes usuários da linguagem aos mais talentosos desenvolvedores de R, todos, sem excessão, acabam recorrendo a internet como uma valiosa fonte de informação e ajuda. Existem livros gratuitos, blogs com excelentes tutoriais, fóruns e sites de perguntas e respostas (Q&amp;A). Neste último caso, não há como não mencionar o StackOverflow, que é um site de perguntas e respostas especializado em programação em geral. A comunidade de R no StackOverflow é extremamente ativa e uma das maiores do site. Lá você encontrará usuários iniciantes, intermediários, avançados, desenvolvedores de pacotes e até mesmo gente que atua na atualização da linguagem e do RStudio. Há uma versão em português e uma em inglês. Recorra à versão em inglês do site, por ser obviamente muito mais ativa. Antes de postar uma pergunta lá faça uma busca com os termos que deseja, por exemplo: “How do a scatter plot in R?”. Se digitar isso na busca do site ou mesmo no Google, nos primeiros resultados você já terá as respostas necessárias do StackOverflow para fazer um scatterplot no R, pelo menos de 3 formas diferentes, usando pacotes diferentes. Veja um exemplo de pergunta e resposta no StackOverflow: Pergunta Resposta 1.2 Estrutura de Objetos da Linguagem R Entender a estrutura de criação e manipulação de objetos no R será essencial para impulsionar sua velocidade de aprendizado nas demais sessões do curso. O bom aproveitamento dos tópicos mais práticos dependem muito de um entendimento sólido sobre os objetos da linguagem R. Tudo (ou quase tudo) no R são objetos. Os mais importantes são: Vetores: são uma espécie de array unidimensional. Consistem em uma sequência de valores que podem ser: numéricos, caracteres ou expressões lógicas (como TRUE ou FALSE). Ressalta-se que as entradas de um vetor podem ser somente de um único tipo. Exemplo: ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 Matrizes: são arrays multidimensionais com coleção de vetores em linhas ou colunas, sendo que todos os vetores da coleção possuem o mesmo tipo e tamanho. Exemplo: ## [,1] [,2] ## [1,] &quot;R&quot; &quot;IPEA&quot; ## [2,] &quot;IPEA&quot; &quot;R&quot; ## [3,] &quot;R&quot; &quot;IPEA&quot; ## [4,] &quot;IPEA&quot; &quot;R&quot; ## [5,] &quot;R&quot; &quot;IPEA&quot; Dataframes: em termos de aparência, são praticamente idênticos às matrizes, mas com a possibilidade de se ter uma coleção de vetores (colunas) de diferentes tipos (ex: um vetor numérico e outro vetor de caracteres). Por essa característica, é o principal objeto utilizado para armazenar tabelas de dados no R. Exemplo: ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa Listas: é o tipo mais amplo de objeto, que pode reunir coleções de dataframes, vetores e/ou matrizes, ou ainda de todos eles. Uma característica da lista é que, uma vez que os objetos dentro dela não precisam ser do mesmo tipo, também não há a necessidade de que sejam do mesmo tamanho. Isso, muitas vezes, é de grande auxílio na manipulação de dados. Exemplo: ## [[1]] ## [1] &quot;R&quot; &quot;IPEA&quot; &quot;2020&quot; ## ## [[2]] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## ## [[3]] ## [,1] [,2] ## [1,] 0.9659412 0.8334877 ## [2,] 0.1669618 0.3301778 Funções: são um conjunto de procedimentos que recebem zero, um ou mais parâmetros como input, realizam um cálculo ou procedimento e retornam um resultado para o usuário. Como você pode perceber até funções são consideradas objetos no R. Exemplo: ## function (x, base = exp(1)) .Primitive(&quot;log&quot;) Nesta seção, estudaremos mais a fundo a criação e manipulação de vetores e Dataframes, que julgamos serem os objetos mais importantes para este curso. A criação de funções será objeto de estudo do Módulo 1.2.1 Vetores 1.2.1.1 Como criar um vetor No R há 3 tipos de vetores: númericos (numeric), de caracteres ou strings (character) e vetores lógicos (logic). Todos eles são criados por meio da função c(), sendo o “c” de concatenate. Esta função faz a concatenação de elementos de um mesmo tipo, produzindo, assim um vetor. Os parâmetros a serem passados são os elementos que comporão o vetor e devem ser separados por vírgulas. Vetor numérico: v1 &lt;- c(1, 0.2, 0.3, 2, 2.8); v1 ## [1] 1.0 0.2 0.3 2.0 2.8 DICA: Ao usar ;, você indica ao R que está separando a execução do código, embora haja duas operações na mesma linha - uma que cria o vetor e outra que imprime o resultado no console ao chamar o nome do objeto. DICA: Os vetores numéricos podem ser de dois tipos: integer, para números inteiros ou double, para ponto flutuante (números decimais). Para saber o tipo de um vetor, use a função typeof(nome_vetor) Vetor de caracteres ou strings: v2 &lt;- c(&quot;R&quot;, &quot;IPEA&quot;, &quot;2020&quot;, &quot;R&quot;, &quot;IPEA&quot;, &quot;2020&quot;); v2 ## [1] &quot;R&quot; &quot;IPEA&quot; &quot;2020&quot; &quot;R&quot; &quot;IPEA&quot; &quot;2020&quot; DICA: Note que as strings devem ser passadas \"entre aspas\". Vetor lógico: v3 &lt;- c(TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE); v3 ## [1] TRUE FALSE FALSE TRUE TRUE FALSE FALSE TRUE Experimente misturar dois vetores. Como os vetores só podem ser de um único tipo, o R automaticamente forçara o resultado final para um único tipo. Exemplo: v4 &lt;- c(v1, v2); v4 ## [1] &quot;1&quot; &quot;0.2&quot; &quot;0.3&quot; &quot;2&quot; &quot;2.8&quot; &quot;R&quot; &quot;IPEA&quot; &quot;2020&quot; &quot;R&quot; &quot;IPEA&quot; &quot;2020&quot; v5 &lt;- c(v1, v3); v5 ## [1] 1.0 0.2 0.3 2.0 2.8 1.0 0.0 0.0 1.0 1.0 0.0 0.0 1.0 v6 &lt;- c(v2, v3); v6 ## [1] &quot;R&quot; &quot;IPEA&quot; &quot;2020&quot; &quot;R&quot; &quot;IPEA&quot; &quot;2020&quot; &quot;TRUE&quot; &quot;FALSE&quot; &quot;FALSE&quot; &quot;TRUE&quot; &quot;TRUE&quot; &quot;FALSE&quot; &quot;FALSE&quot; ## [14] &quot;TRUE&quot; seq(-1, -10) ## [1] -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 A função typeof(nome_do_vetor) pode ser usada para confirmar os tipos dos vetores que você criou. 1.2.1.1.1 Outras formas de criar um vetor Há outras funções interessantes que possibilitam criar vetores: :, exemplo: 1:100, cria um vetor numérico composto pela sequência de 1 a 100; seq(), exemplo: seq(-10, -1), cria um vetor numérico composto pela sequência de -10 a -1; rep(), exemplo: rep(\"IPEA\", 10), cria um vetor composto pela string \"IPEA\" repetida 10 vezes. 1.2.1.2 Como extrair elementos de um vetor Para extrair elementos de um vetor (e de qualquer objeto no R), utilizamos a indexação por meio de colchetes nome_do_vetor[posição]. Você pode informar uma única posição, um conjunto de posições ou mesmo um intervalo de posições a extrair: Extraindo um único elemento: # 3º elemento do vetor v1 v1[3] ## [1] 0.3 # 1º elemento do vetor v2 v2[1] ## [1] &quot;R&quot; # 5º elemento do vetor v3 v3[5] ## [1] TRUE Extraindo mais de uma elemento: Aqui você usará um vetor dentro de outro vetor. A ideia é que o vetor dentro dos colchetes [] contenha as posições (índices) a serem extraídas do vetor original. Lembre-se que o vetor contendo as posições deverá ser criado e, para criar um vetor, usamos a função c(). # 1º e 3º elementos do vetor v1 v1[c(1,3)] ## [1] 1.0 0.3 # ou pos1 &lt;- c(1,3) v1[pos1] ## [1] 1.0 0.3 # 2º e 4º elemento do vetor v2 v2[c(2,4)] ## [1] &quot;IPEA&quot; &quot;R&quot; # ou pos2 &lt;- c(1,3) v2[pos2] ## [1] &quot;R&quot; &quot;2020&quot; # 1º, 2º e 5º elemento do vetor v3 v3[c(1,2,5)] ## [1] TRUE FALSE TRUE # ou pos3 &lt;- c(1,2,5) v3[pos3] ## [1] TRUE FALSE TRUE Extraindo elementos em um intervalo: Mais uma vez usaremos vetor dentro de vetor. A diferência é que criaremos um vetor utilizando a função :, a qual cria uma sequência de valores ou intervalo. Podemos utilizar ainda a função seq(a,b) # do 1º ao 3º elementos do vetor v1 v1[1:3] ## [1] 1.0 0.2 0.3 # ou v1[seq(1,3)] ## [1] 1.0 0.2 0.3 # do 2º ao 5º elemento do vetor v2 v2[2:5] ## [1] &quot;IPEA&quot; &quot;2020&quot; &quot;R&quot; &quot;IPEA&quot; # ou v2[seq(2,5)] ## [1] &quot;IPEA&quot; &quot;2020&quot; &quot;R&quot; &quot;IPEA&quot; # do 3º ao 6º elemento do vetor v3 v3[2:6] ## [1] FALSE FALSE TRUE TRUE FALSE # ou v3[seq(2,6)] ## [1] FALSE FALSE TRUE TRUE FALSE 1.2.1.3 Como calcular o tamanho de um vetor? DICA: Para calcular o tamanho de um vetor, use a função length(nome_vetor): length(v6) ## [1] 14 1.2.1.4 Como alterar elementos de um vetor Uma vez que você entendeu o processo de indexação de vetores. Você pode alterar ou substituir um ou mais elementos de um vetor, usando ndexação e atribuição. v1[2] &lt;- 450.78 v2[3] &lt;- 2021 v3[c(3,5)] &lt;- c(TRUE, FALSE) # a substituição tem que ser do mesmo tamanho do resultado da indexação 1.2.2 Dataframes Os Dataframes são as “tabelas” do R. Provavelmente será um dos objetos que você mais utilizará para fazer análise de dados. O Dataframe possui linhas e colunas. Pense nas colunas como vetores, onde cada uma das posições desse vetor indica uma linha. Podemos pensar os Dataframes, então, como uma coleção de vetores, que podem inclusive ser de tipos diferentes, mas necessariamente devem possuir o mesmo tamanho. Isso faz todo sentido, pois numa tabela temos variáveis numéricas, nomes, e outros tipos que não serão tratados neste curso, como datas, por exemplo. 1.2.2.1 Como criar um Dataframe Para criarmos um dataframe, utilizamos a função data.frame(). No entanto, o mais comum é que o dataframe seja criado a a partir da leitura de alguma base de dados, por meio das funções de leitura que serão apresentadas principalmente no Módulo 2. Vamos criar um dataframe de 3 colunas. Os argumentos principais são os vetores que compõem as colunas. # OBS: todos os vetores precisam ter o mesmo tamanho v6 &lt;- 11:15 v7 &lt;- seq(0.3, 0.7, by=0.1) v8 &lt;- rep(&quot;IPEA&quot;, 5) v9 &lt;- rep(c(TRUE, FALSE), 5) df1 &lt;- data.frame(v6, v7, v8, v9) df1 ## v6 v7 v8 v9 ## 1 11 0.3 IPEA TRUE ## 2 12 0.4 IPEA FALSE ## 3 13 0.5 IPEA TRUE ## 4 14 0.6 IPEA FALSE ## 5 15 0.7 IPEA TRUE ## 6 11 0.3 IPEA FALSE ## 7 12 0.4 IPEA TRUE ## 8 13 0.5 IPEA FALSE ## 9 14 0.6 IPEA TRUE ## 10 15 0.7 IPEA FALSE DICA: Há vários outros argumentos que também podem ser usados. Vejamos a estrutura da função data.frame(). Vale a pena consultar o help da função data.frame também (help(data.frame)). data.frame help(&quot;data.frame&quot;) Durante a criação de um dataframe, podemos escolher outros nomes para as colunas: df1 &lt;- data.frame(col1 = v6, col2 = v7, col3 = v8, col4 = v9) # ou # df1 &lt;- data.frame(&quot;col1&quot; = v6, &quot;col2&quot; = v7, &quot;col3&quot; = v8, &quot;col4&quot; = v9) df1 ## col1 col2 col3 col4 ## 1 11 0.3 IPEA TRUE ## 2 12 0.4 IPEA FALSE ## 3 13 0.5 IPEA TRUE ## 4 14 0.6 IPEA FALSE ## 5 15 0.7 IPEA TRUE ## 6 11 0.3 IPEA FALSE ## 7 12 0.4 IPEA TRUE ## 8 13 0.5 IPEA FALSE ## 9 14 0.6 IPEA TRUE ## 10 15 0.7 IPEA FALSE Você deve ter notado que há sempre um coluna à esquerda que contem a numeração ou nomes das linhas do seu dataframe. É o que chamamos de rownames. DICA: Se você quiser confirmar a estrutura de seu dataframe, ou seja, saber o tipo de suas colunas, use a função str(nome_data_frame) str(df1) ## &#39;data.frame&#39;: 10 obs. of 4 variables: ## $ col1: int 11 12 13 14 15 11 12 13 14 15 ## $ col2: num 0.3 0.4 0.5 0.6 0.7 0.3 0.4 0.5 0.6 0.7 ## $ col3: chr &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; ... ## $ col4: logi TRUE FALSE TRUE FALSE TRUE FALSE ... Note que a coluna 2 col2 foi tratada como factor e não como character, como esperávamos. factor é uma abstração que o R utiliza para salvar variáveis categóricas na memória de modo a ocupar menos espaço. Basicamente, ele converte as categorias em um número, de modo a otimizar a utilização de memória. Se a variável for impressa no console, ele faz uma reconversão apenas para apresentá-la ao usuário. Para que a col2 seja realmente criada como uma coluna do tipo character, devemos setar o parâmetro stringsAsFactors = FALSE. Guarde bem essa dica, pois você usará esse mesmo parâmetro ao ler dados externos, transformando-os em dataframes no R. df1 &lt;- data.frame(col1 = v6, col2 = v7, col3 = v8, col4 = v9, stringsAsFactors = FALSE) str(df1) ## &#39;data.frame&#39;: 10 obs. of 4 variables: ## $ col1: int 11 12 13 14 15 11 12 13 14 15 ## $ col2: num 0.3 0.4 0.5 0.6 0.7 0.3 0.4 0.5 0.6 0.7 ## $ col3: chr &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; ... ## $ col4: logi TRUE FALSE TRUE FALSE TRUE FALSE ... DICA: A partir da versão 4.0.0, não é mais necessário declarar stringsAsFactors = FALSE na função data.frame. Este passou a ser o comportamento padrão da função: não transformar colunas de strings em fatores. Note que, diferentemente dos vetores que eram unidimensionais, os dataframes são bidimensionais. Temos uma dimensão representada pelas linhas e outra dimensão representada pelas colunas. Para calcular as dimensões de seu dataframe você pode usar utilizar as seguintes funções: # linhas vs colunas dim(df1) ## [1] 10 4 # nro de linhas nrow(df1) ## [1] 10 # nro de colunas ncol(df1) ## [1] 4 1.2.2.2 Como extrair elementos de um Dataframe Para extrair os elementos de um Dataframe, utilizaremos a mesma técnica de indexação dos vetores, usando colchetes []. A diferença é que, como o Dataframe possui duas dimensões, precisamos trabalhar com ambas, separando os índices de cada dimensão com um vírgula dentro dos colchetes nome_df[índice_linhas, indice_colunas]. Agora, os valores que passarmos dentro dos colchetes referem-se às linhas ou as colunas de um Dataframe. É como jogar batalha naval. DICA: Se você quiser extrair apenas linha(s) inteira(s), deixe a dimensão da coluna em branco, ex: nome_df[linha_X, ]. Se você quiser extrair apenas coluna(s), deixe a dimensão das linhas em branco, ex: nome_df[, coluna_Y]. Extraindo uma ou mais linhas: # única linha df1[3, ] ## col1 col2 col3 col4 ## 3 13 0.5 IPEA TRUE # algumas linhas # note o posicionamento das vírgulas df1[c(1,2,5), ] ## col1 col2 col3 col4 ## 1 11 0.3 IPEA TRUE ## 2 12 0.4 IPEA FALSE ## 5 15 0.7 IPEA TRUE # uma sequência de linhas df1[3:5, ] ## col1 col2 col3 col4 ## 3 13 0.5 IPEA TRUE ## 4 14 0.6 IPEA FALSE ## 5 15 0.7 IPEA TRUE Extraindo uma ou mais colunas: # única coluna df1[ ,2] ## [1] 0.3 0.4 0.5 0.6 0.7 0.3 0.4 0.5 0.6 0.7 # algumas colunas # note o posicionamento das vírgulas df1[, c(2,3)] ## col2 col3 ## 1 0.3 IPEA ## 2 0.4 IPEA ## 3 0.5 IPEA ## 4 0.6 IPEA ## 5 0.7 IPEA ## 6 0.3 IPEA ## 7 0.4 IPEA ## 8 0.5 IPEA ## 9 0.6 IPEA ## 10 0.7 IPEA # uma sequência de colunas df1[, 2:4] ## col2 col3 col4 ## 1 0.3 IPEA TRUE ## 2 0.4 IPEA FALSE ## 3 0.5 IPEA TRUE ## 4 0.6 IPEA FALSE ## 5 0.7 IPEA TRUE ## 6 0.3 IPEA FALSE ## 7 0.4 IPEA TRUE ## 8 0.5 IPEA FALSE ## 9 0.6 IPEA TRUE ## 10 0.7 IPEA FALSE Extraindo elementos específicos, cruzando linhas e colunas Você pode misturar índices de ambas dimensões, para extrair subconjuntos específicos do seu Dataframe. É como jogar batalha naval: # elemento único # elemento no cruzamento da 2ºlinha e 3º coluna df1[2, 3] ## [1] &quot;IPEA&quot; # subconjuntos # elementos no cruzamento da 2ª e 5ª linha vs 1ª e 4ª coluna df1[c(2,5), c(1,4)] ## col1 col4 ## 2 12 FALSE ## 5 15 TRUE # subconjuntos # sequência da 2ª a 4ª linha vs sequência da 3ª a 5ª linha df1[1:3, 2:4] ## col2 col3 col4 ## 1 0.3 IPEA TRUE ## 2 0.4 IPEA FALSE ## 3 0.5 IPEA TRUE DICA: Você também pode misturar os exemplos anteriores, por exemplo: df1[2, 2:4]. 1.2.2.3 Outras formas de indexar as colunas de um Dataframe Há mais duas formas de indexar as colunas de um Dataframe. Ambas utilizam os nomes das colunas e não os índices. Primeira forma alternativa: df1[, &quot;col2&quot;] ## [1] 0.3 0.4 0.5 0.6 0.7 0.3 0.4 0.5 0.6 0.7 Segunda forma alternativa: df1$col3 ## [1] &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; &quot;IPEA&quot; Note que o output é impresso na horizontal Isso ocorre, porque, quando extraímos apenas uma coluna, estamos extraindo um vetor. E a forma de output de um vetor é na horizontal, como vimos anteriormente. 1.2.3 Referências do Módulo Estatística Computacional 2 (2015). Notas de aula. Curso de Estatística, UnB, 1º semestre, 2015. Nyffenegger, R. (2020). R: a computer language for statistical data analysis. URL https://renenyffenegger.ch/notes/development/languages/R/. Wickham, H. (2014). Advanced R. September 25, 2014. Chapman and Hall/CRC. 476 Pages. Disponível em: https://adv-r.hadley.nz/. R Core Team (2020). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL http://www.R-project.org/. 1.2.4 Exercícios 1) Vetores Crie dois vetores numéricos (A e B) de tamanho 10 com números aleatórios escolhidos por você. Multiplique todos os itens do vetor A por \\(\\times3\\) e os itens do vetor B por \\(\\times4\\). Crie um novo vetor (C) resultante da operação de \\(\\frac{log(B)}{|A| + (A+B)}\\), onde \\(|A|\\) é o tamanho do vetor A. Crie um novo vetor lógico (D), verificando quais valores de A são maiores que os respectivos valores de B. Acrescente 3 nomes escolhidos por você ao final de cada vetor. Os vetores mudam de tipo? 2) Dataframes Crie um Dataframe de 10 linhas e 5 colunas, com pelo menos 3 colunas de tipos diferentes, sendo pelo menos duas númericas. Crie uma 6ª coluna resultante da soma entre duas colunas numéricas do Dataframe. Esolha duas colunas numéricas A e B, e crie uma 7ª coluna resultante da operação de \\(\\frac{log(B)}{|A| + (A+B)}\\), onde \\(|A|\\) é o tamanho da coluna A. "],["m2.html", " 2 Módulo II 2.1 Leitura de Dados no R 2.2 Manipulação de dados com dplyr 2.3 Gráficos com ggplot2", " 2 Módulo II 2.1 Leitura de Dados no R Até o momento, trabalhamos criando objetos a partir de dados informados via script ou console. No entanto, o mais comum quando se faz análise de dados, é ler dados a partir de fontes externas, como um arquivo .txt ou .csv, um banco de dados relacional (SQL) no servidor de nossa empresa, ou ainda, a partir de páginas da internet. Nesta seção, veremos como ler bases de dados armazenadas localmente no computador. Eu costumo dizer que, em R, sempre há pelo menos 3 formas diferentes de realizar uma mesma tarefa. No caso da leitura de dados, isso não é diferente, uma vez que o R possui diversos pacotes para realizar a leitura dos dados; uns focam na rapidez, outros na praticidade e outros, ainda, são feitos especificamente para manusear bases de dados massivas. Quanto a esse último aspecto, há de se reconhecer que o R não tem um gerenciamento de memória que permita ao usuário carregar bancos de dados muito grandes (na casa das 10 milhões de linhas mais ou menos). Isso é, de certa forma, proposital, uma vez que o R foi criado para tornar mais fácil a vida do usuário que lida com análise dados. Mas há que se ressaltar que, devido a sua comunidade extremamente ativa, vários pacotes foram e vem sendo desenvolvidos com o objetivo de melhorar a forma como o R lida com o armazenamento de objetos na memória. Neste curso, nós focaremos na utilização do pacote readr, por entendermos ser um meio termo entre praticidade e rapidez, considerando as alternativas do base R e de funções similares, porém muito mais rápidas, como as disponíveisnos pacotes data.table, vroom, dentre outros. 2.1.1 O Tidyverse O readr compõe um conjunto de pacotes chamado de Tidyverse. “The tidyverse is a set of packages that work with harmony because they share common data representtions and API design. The tidyverse package is designed to make it easy to install and load core packages from the tidyverse in a single command.” * Hadley Wickham * Hexsticker do Tidyverse Podemos definir o Tidyverse, então, como um meta-package que congrega uma coleção de diversos outros pacotes R voltados para importação, exploração, manipulação e visualização de dados. Vão desde pacotes para manipulação de strings, expressões regulares, datas, passando por pacotes de leitura e importação, manipulação e visualização de dados, até a geração de relatórios e criação de páginas web, dentre outras coisas. Esses pacotes buscam propiciar uma maior padronização e facilidade na forma de lidar com dados no R. 2.1.2 Leitura e Exportação de Dados usando readr O objetivo do pacote readr é tornar mais fácil e amigável a leitura de bases de dados retangulares/tabulares (csv, txt e fwf) no R. Comparado às alternativas do base R, o readr é mais inteligente no sentido de tentar advinhar os formatos das colunas dos dados, ainda permitindo, se necessário, a especificação de padrões pelo usuário. As funções de leitura mais importantes no pacote são: read_csv(): lê arquivos .csv ou .txt no formato americano, onde o separador de colunas é a vírgula; read_csv2(): lê arquivos .csv ou .txt no formato pt-br, onde o separador de colunas é o ponto e vírgula; read_tsv(): lê arquivos .csv ou .txt, onde o separador de colunas é o tab \\t; read_table(): lê arquivos .txt, onde o separador de colunas é é o espaço em branco`; read_delim(): permite ler arquivos de diversas extensões, onde o usuário pode especificar o delimitador por meio do parâmetro delim. Vamos para a prática, utilizando dados editados a partir da base Produção Madeireira de Espécies Nativas Brasileiras: 2012 a 2017 publicada pelo IBAMA. Há diversas bases nesse site, bem como scripts em R para facilitar a manipulação dos dados. Você pode baixar os dados. No entanto, como nosso objetivo é criar a experiência de leitura, editamos aleatoriamente essa base, reduzindo seu tamanho para 100 mil linhas, e a disponibilizamos neste LINK. Uma vez na página, você pode salvá-la em seu computador clicando com o botão direito do mouse e depois em Salvar como. Note que os dados estão em um arquivo .csv no padrão norte-americano (colunas separadas por vírgulas ,). Vamos fazer a leitura do arquivo que foi salvo em nosso computador. DICA: No seu computador, o caminho para o arquivo será outro. library(readr) tb_ibama &lt;- read_csv(file=&quot;C:\\\\Users\\\\...\\\\PA GF 2017 jan-jun_editada.csv&quot;) # ou utilizando a função mais genérica tb_ibama &lt;- read_delim(file=&quot;C:\\\\Users\\\\...\\\\PA GF 2017 jan-jun_editada.csv&quot;, delim = &quot;,&quot;) Se você não quiser salvar a base em seu computador, lendo o arquivo direto do site, você também pode. É só copiar o endereço do arquivo apresentado no browser e passar para o argumento file. Caminhos passados para o argumento file começados em http://, https://, ftp://, ou ftps:// resultam no download e leitura automática do arquivo. ## Rows: 100000 Columns: 17 ## ── Column specification ──────────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (13): TIPO_GF, STATUS_GF, UF_REMETENTE, MUNICÍPIO_REMETENTE, TIPO_DESTINO, CEPROF_DESTINATÁRIO, UF_DESTI... ## dbl (4): X1, EMISSAO, VOLUME, PRECO_TOTAL ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. Note que assim que o arquivo é lido, as funções imprimem no console os nomes de cada coluna e as formas como elas foram lidas. Isto permite ao usuário checar se tudo ocorreu bem durante a leitura. Caso alguma coluna não tenha sido lida no formato em que você esperava, é só copiar a saída e rodar a função novamente, mudando a especificação daquela coluna em particular. Por exemplo, vamos alterar a coluna EMISSAO de ponto flutante/decimal double (que ocupa mais espaço na memória), para que seja lida como número inteiro integer. Fazemos essa especificação no argumento col_types. tb_ibama &lt;- read_csv(file=&quot;https://raw.githubusercontent.com/allanvc/book_IADR-T/master/datasets/PA%20GF%202017%20jan-jun_editada.csv&quot;, col_types = cols( X1 = col_double(), TIPO_GF = col_character(), STATUS_GF = col_character(), UF_REMETENTE = col_character(), MUNICÍPIO_REMETENTE = col_character(), TIPO_DESTINO = col_character(), CEPROF_DESTINATÁRIO = col_character(), UF_DESTINATÁRIO = col_character(), MUNICÍPIO_DESTINATÁRIO = col_character(), N_AUTORIZAÇÃO = col_character(), PROCESSO = col_character(), EMISSAO = col_integer(), NOME_CIENTÍFICO = col_character(), PRODUTO = col_character(), VOLUME = col_double(), UNID = col_character(), PRECO_TOTAL = col_double() ) ) Uma vez lido o arquivo, podemos inspecioná-lo chamando o objeto criado, ou clicando no nome do objeto em nosso environment. tb_ibama ## # A tibble: 100,000 × 17 ## X1 TIPO_GF STATUS_GF UF_REMETENTE MUNICÍPIO_REMETENTE TIPO_DESTINO CEPROF_DESTINATÁRIO UF_DESTINATÁRIO ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 40644 GF1 RECEBIDO PA Santarém EMPREENDIMENTO… XXXX PA ## 2 153879 GF1 RECEBIDO PA Alenquer EMPREENDIMENTO… XXXX PA ## 3 66847 GF1 RECEBIDO PA Rurópolis EMPREENDIMENTO… XXXX PA ## 4 319645 GF3I RECEBIDO PA Tucuruí EMPREENDIMENTO… &lt;NA&gt; BA ## 5 19190 GF3 RECEBIDO PA Paragominas EMPREENDIMENTO… XXXX PA ## 6 317951 GF2 RECEBIDO PA Breu Branco EMPREENDIMENTO… XXXX PA ## 7 201275 GF3I RECEBIDO PA Benevides EMPREENDIMENTO… &lt;NA&gt; BA ## 8 275969 GF3I RECEBIDO PA Tucuruí EMPREENDIMENTO… &lt;NA&gt; BA ## 9 158094 GF3I RECEBIDO PA Moju EMPREENDIMENTO… &lt;NA&gt; SE ## 10 181537 GF1 RECEBIDO PA Santarém EMPREENDIMENTO… XXXX PA ## # ℹ 99,990 more rows ## # ℹ 9 more variables: MUNICÍPIO_DESTINATÁRIO &lt;chr&gt;, N_AUTORIZAÇÃO &lt;chr&gt;, PROCESSO &lt;chr&gt;, EMISSAO &lt;int&gt;, ## # NOME_CIENTÍFICO &lt;chr&gt;, PRODUTO &lt;chr&gt;, VOLUME &lt;dbl&gt;, UNID &lt;chr&gt;, PRECO_TOTAL &lt;dbl&gt; Note que esse arquivo não se parece muito com o formato clássico de Dataframe que vimos no Módulo 1. Ele na verdade é um novo tipo de objeto, que segue a filosofia do Tydeverse, comentada na seção anterior. Temos aqui um tibble, que nada mais é que um Dataframe mais amigável. Em termos gerais, a diferença de um Dataframe clássico para um tibble está principalmente nas informações que nos são apresentadas quando imprimimos o conteúdo do objeto no console. Diferentemente do Dataframe, um tibble nos apresenta apenas as 10 primeiras linhas da tabela, os tipos das colunas, e apenas o conteúdo das colunas que cabem em nossa tela. Uma outra diferença é no resultado ao executarmos uma identificação. Ainda podemos utilizar [indice_linhas, indice_colunas] ou nome_dataframe$nome_coluna. A questão é que indexações com chaves, retornaram um tibble, mesmo que a operação resulte em uma única coluna. Já a indexação via $, retornará um vetor. Resumindo, a primeira não altera o tipo de objeto - continuamos com um tibble. A segunda altera o tipo de objeto. Teste isso na prática: tb_ibama[,&quot;TIPO_GF&quot;] # ou tb_ibama[,2] tb_ibama$TIPO_GF Outras vantagens do tibble são: não precisarmos mais nos preocupar com stringsAsFactors=FALSE; ele funciona de forma muito mais fluida com os demais pacotes do tidyverse que utilizaremos mais a frente no curso; 2.1.2.1 Alternativas Quando se trata de leitura de dados, há muitas alternativas no R. Embora não pertença ao escopo deste curso, sugerimos que você estude o funcionamento das funções da família read.table() do base R. Essas funções são mais lentas que as funções do pacote readr, mas apresentam maior flexibilidade em relação à especificação de parâmetros. No quesito grande bancos de dados, com milhões de observações, sugerimos a função fread() do pacote data.table. MAs essa velocidade vem com o preço de se ter que aprender um paradigma um pouco diferente de programação, mesmo sendo dentro do R. Muitas pessoas também tem interesse em ler dados que estão em planilhas ou abas de planilhas Excel em formatos .xls e .xlsx. Embora não seja a forma mais adequada de armazenar dados, é válido saber que existe uma alternativa para a leitura de dados do Excel. Leia sobre o pacote readxl e a função read_excel(). 2.1.3 Escrita e exportação de dados Apesar do nome, o pacote readrtambém possui funções para escrita de dados. Para exportarmos o resultado de nossas análises no R para uma tabela de extensão .txt ou .csv, por exemplo, vamos recorrer a funções bastante parecidas com as de leitura, alterando apenas os prefixos de read para write. Os sufixos, novamente, dependerão, do tipo de arquivo que se deseja gravar. As funções mais utilizadas são: write.csv(); ẁrite_csv2; write_table(); e write.delim(). Vamos alterar o arquivo tb_ibama para, então, exportarmos a nova versão como um novo arquivo .csv no padrão pt-br. Utilizando o conhecimento sobre indexação de objetos do Módulo 1, vamos substituir as 50 mil primeiras linhas da coluna STATUS_GF para NÃO VERIFICADO, e eliminar a primeira coluna, que era uma coluna de índices. 1º) mudando o status tb_ibama[1:50000, &quot;STATUS_GF&quot;] &lt;- rep(&quot;NÃO VERIFICADO&quot;, 50000) # ou tb_ibama[1:50000, 3] &lt;- rep(&quot;NÃO VERIFICADO&quot;, 50000) # ou tb_ibama$STATUS_GF[1:50000] &lt;- rep(&quot;NÃO VERIFICADO&quot;, 50000) 2º) excluindo a primeira coluna No R, temos uma palavra reservada pela linguagem que transforma os objetos ou elementos de um objeto em vazios. É a palavra NULL. tb_ibama[, &quot;X1&quot;] &lt;- NULL # ou tb_ibama[, 1] &lt;- NULL # ou tb_ibama_modif &lt;- tb_ibama[, 2:ncol(tb_ibama)] # substituimos a versão completa do tibble por uma versão que traz... #...apenas os dados da coluna 2 em diante 3º) salvando o novo tibble em um arquivo write_csv2(x=tb_ibama, path=&quot;C://caminho//...//tabela_ibama_alterada.csv&quot;) # ou write_delim(x=tb_ibama, path=&quot;C://caminho//...//tabela_ibama_alterada.csv&quot;, delim=&quot;;&quot;) DICA: É muito comum termos dúvidas sobre quais são os prâmetros de uma função e como ela trabalha. Não se esqueça de sempre consultar o Help do R, ou de digitar o nome_da_função do Console, para ver todos os seus parâmetros. 2.1.4 Leitura de dados oriundos do Stata, SAS e SPSS Nós vimos que nesses 20 anos de história, o R cresceu consideravelmente. Durante esse tempo, diversos pesquisadores e profissionais das mais diversas áreas migraram para o R, oriundos principalmente de Stata, SAS e SPSS. Ao encarar o custo da mudança, muitas pessoas se deparam com o desafio de “traduzir” seus scripts de uma linguagem para outra, bem como de lerem dados escritos ou armazenados em extensões usadas por aquelas linguagens. A instalação padrão do R já oferece uma biblioteca para ler bases de dados oriundas de outras linguagens. O nome do pacote faz todo o sentido: foreign. Ele traz diversas funções que tornam simples a importação. Em complemento, recomenda-se a instalação e utilização do pacote HMisc também. A seguir, apresentamos apenas algumas ideias sobre como lidar com datasets “estrangeiros” no R: SPSS: # salvando o dataset no SPSS no formato transport (XPORT) get file=&#39;C:/meus_dados.sav&#39;. export outfile=&#39;C:/meus_dados.por&#39;. # no R # install.packages(&quot;Hmisc&quot;) # caso necessário library(Hmisc) df &lt;- spss.get(&quot;C:/meus_dados_SPSS.por&quot;, use.value.labels=TRUE) # use.value.labels=TRUE converte os valores dos rótulos em factors SAS: # salva o dataset SAS no transport format (XPORT) libname out xport &#39;C:/meus_dados_SAS.xpt&#39;; data out.mydata; set sasuser.mydata; run; # in R library(Hmisc) mydata &lt;- sasxport.get(&quot;C:/meus_dados_SAS.xpt&quot;) # as variaveis do tipo character serão convertidas para factors Stata: library(foreign) mydata &lt;- read.dta(&quot;C:/meus_dados_stata.dta&quot;) 2.1.5 Referências da seção Quick R website. (2020). URL https://www.statmethods.net/. Wickham, H.; Hester, J.; François R. (2018). readr: Read Rectangular Text Data. R package version 1.3.1. URL https://CRAN.R-project.org/package=readr. ____. (2020). readr official website. URL https://readr.tidyverse.org/index.html. Wickham, H.; Grolemund, G. (2016). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. O’Reilly Media. december 2016. 522 pages. Disponível em: https://www.r4ds.co.nz. 2.2 Manipulação de dados com dplyr Nesta seção, trataremos do pacote dplyr, que é um dos pacotes mais importantes da coleção tidyverse. Ele traz uma “gramática” específica de manipulação de dados, provendo um conjunto de funções que ajudam a resolver os desafios mais comuns na manipulação de dados. O objetivo é que você se familiarize com as funções do pacote dplyr; com as tarefas que elas executam; e veja exemplos de como aplicá-las a data.frames. Conforme os próprios autores do pacote apontam, quando trabalhamos com dados, nós precisamos: Descobrir o que desejamos fazer; Descrever essas tarefas na forma de um programa de computador; Executar o programa. O pacote dplyr torna estes passos mais rápidos e fáceis de executar, pois: ao invés de disponibilizar uma imensidão de funções, igual temos no R base e outros pacotes, ele restringe nossas opções e com isso nos ajuda a reciocinar de forma mais direta sobre o que desejamos e podemos fazer com os dados; provém “verbos” (ou funções) mais simples, ou seja, funções que correspondem às tarefas mais comuns de manipulação de dados, ajudando-nos assim a traduzir pensamentos em código; utiliza backends (códigos de final de processo, ou seja, mais próximos ao usuário) eficientes, de modo que gastamos menos tempo esperando pelo computador. O pacote dplyr proporciona uma função para cada “verbo” considerado importante em manipulação de dados: filter() para selecionar “casos” baseados em seus valores; arrange() para reordenar os “casos”; select() e rename() para selecionar variáveis baseadas em seus nomes; mutate() e transmute() para adicionar novas variáveis que são funções de variáveis já existentes nos dados; summarise() ou summarize() para condensar multiplos valores em um único; group_by() embora não seja considerado um dos “verbos”, serve para agruparmos os dados em torno de uma ou mais variáveis. As funções consideradas “verbos” podem ser utilizadas antes ou após o agrupamentodos dados. Veremos agora alguns exemplos de aplicação destas funções. Vamos utilizar o mesmo dataset sobre produção madeireira que utilizamos na seção de leitura e exportação de dados. Ele possui 100.000 mil linhas e 17 colunas. library(dplyr) dim(tb_ibama) ## [1] 100000 16 Note que pelo print que temos novamente um tibble, que é uma forma moderna de data.frame implementada pelo pessoal do tidyverse . Este formato é particularmente útil para grandes datasets porque só é impresso na tela as primeiras linhas e diversos resumos/informações sobre nossas variáveis. Para converter data.frames em tibbles, usamos as_tibble(). 2.2.1 Filtrando linhas com filter() filter() permite fazer um subset das linhas de um tibble/dataframe. Como todos os verbos simples de dplyr, o primeiro argumento será um tibble (ou data.frame). O segundo argumento e os subsequentes se referem a variáveis dentro do data.frame, em que se selecionam as linhas onde a expressão é verdadeira (TRUE). Vamos selecionar todos as linhas em que o tipo de destino das madeiras é o consumidor final, na cidade de Brasil Novo: filter(tb_ibama, TIPO_DESTINO == &quot;CONSUMIDOR_FINAL&quot;, MUNICÍPIO_DESTINATÁRIO == &quot;Brasil Novo&quot;) ## # A tibble: 4 × 16 ## TIPO_GF STATUS_GF UF_REMETENTE MUNICÍPIO_REMETENTE TIPO_DESTINO CEPROF_DESTINATÁRIO UF_DESTINATÁRIO ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 GF3 RECEBIDO_VENCIDO PA Altamira CONSUMIDOR_FINAL &lt;NA&gt; PA ## 2 GF3 RECEBIDO_VENCIDO PA Altamira CONSUMIDOR_FINAL &lt;NA&gt; PA ## 3 GF3 RECEBIDO_VENCIDO PA Altamira CONSUMIDOR_FINAL &lt;NA&gt; PA ## 4 GF3 RECEBIDO_VENCIDO PA Altamira CONSUMIDOR_FINAL &lt;NA&gt; PA ## # ℹ 9 more variables: MUNICÍPIO_DESTINATÁRIO &lt;chr&gt;, N_AUTORIZAÇÃO &lt;chr&gt;, PROCESSO &lt;chr&gt;, EMISSAO &lt;int&gt;, ## # NOME_CIENTÍFICO &lt;chr&gt;, PRODUTO &lt;chr&gt;, VOLUME &lt;dbl&gt;, UNID &lt;chr&gt;, PRECO_TOTAL &lt;dbl&gt; DICA: No base R, isso seria equivalente ao código: tb_ibama[tb_ibama$TIPO_DESTINO == \"CONSUMIDOR_FINAL\" &amp; tb_ibama$MUNICÌPIO_DESTINATÁRIO == \"Brasil Novo\", ]. 2.2.2 Ordenando linhas com arrange() arrange() funciona de modo semelhante a filter, mas ao invés de filtrar e selecionar linhas, ele apenas as reordena de acordo com alguma condição que passamos. Essa função recebe um data.frame e um conjunto de column names pelo qual vai ordenar. Se você fornecer mais de um nome de coluna, cada coluna adicional passada será usada como critério de desempate. arrange(tb_ibama, UF_DESTINATÁRIO, MUNICÍPIO_DESTINATÁRIO, VOLUME) ## # A tibble: 100,000 × 16 ## TIPO_GF STATUS_GF UF_REMETENTE MUNICÍPIO_REMETENTE TIPO_DESTINO CEPROF_DESTINATÁRIO UF_DESTINATÁRIO ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 GF3I RECEBIDO PA Tomé-Açu EMPREENDIMENTO_IBAMA &lt;NA&gt; AL ## 2 GF3I RECEBIDO PA Tomé-Açu EMPREENDIMENTO_IBAMA &lt;NA&gt; AL ## 3 GF3I RECEBIDO PA Tomé-Açu EMPREENDIMENTO_IBAMA &lt;NA&gt; AL ## 4 GF3I RECEBIDO PA Paragominas EMPREENDIMENTO_IBAMA &lt;NA&gt; AL ## 5 GF3I RECEBIDO PA Tomé-Açu EMPREENDIMENTO_IBAMA &lt;NA&gt; AL ## 6 GF3I RECEBIDO PA Ipixuna do Pará EMPREENDIMENTO_IBAMA &lt;NA&gt; AL ## 7 GF3I RECEBIDO PA Rondon do Pará EMPREENDIMENTO_IBAMA &lt;NA&gt; AL ## 8 GF3I RECEBIDO PA Novo Repartimento EMPREENDIMENTO_IBAMA &lt;NA&gt; AL ## 9 GF3I RECEBIDO PA Rondon do Pará EMPREENDIMENTO_IBAMA &lt;NA&gt; AL ## 10 GF3I RECEBIDO PA Tomé-Açu EMPREENDIMENTO_IBAMA &lt;NA&gt; AL ## # ℹ 99,990 more rows ## # ℹ 9 more variables: MUNICÍPIO_DESTINATÁRIO &lt;chr&gt;, N_AUTORIZAÇÃO &lt;chr&gt;, PROCESSO &lt;chr&gt;, EMISSAO &lt;int&gt;, ## # NOME_CIENTÍFICO &lt;chr&gt;, PRODUTO &lt;chr&gt;, VOLUME &lt;dbl&gt;, UNID &lt;chr&gt;, PRECO_TOTAL &lt;dbl&gt; Se quiser ordenar de forma decrescente, utilize a função desc(nome_da_coluna) dentro de arrange(). Isso seria particularmente interessante se você quisesse ordenar os dados na coluna final do maior volume para o maior. 2.2.3 Selecionando colunas com select() Geralmente trabalhamos com grandes datasets com muitas colunas, mas somente algumas poucas colunas serão de nosso interesse. select() nos permite rapidamente focar num subconjunto dos dados. O melhor é que podemos utilizar operações - que normalmente só funcionam com as posições das colunas - direto nos nomes das variáveis. # Seleção por nome select(tb_ibama, UF_REMETENTE, MUNICÍPIO_REMETENTE, TIPO_DESTINO) ## # A tibble: 100,000 × 3 ## UF_REMETENTE MUNICÍPIO_REMETENTE TIPO_DESTINO ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 PA Santarém EMPREENDIMENTO_CEPROF ## 2 PA Alenquer EMPREENDIMENTO_CEPROF ## 3 PA Rurópolis EMPREENDIMENTO_CEPROF ## 4 PA Tucuruí EMPREENDIMENTO_IBAMA ## 5 PA Paragominas EMPREENDIMENTO_CEPROF ## 6 PA Breu Branco EMPREENDIMENTO_CEPROF ## 7 PA Benevides EMPREENDIMENTO_IBAMA ## 8 PA Tucuruí EMPREENDIMENTO_IBAMA ## 9 PA Moju EMPREENDIMENTO_IBAMA ## 10 PA Santarém EMPREENDIMENTO_CEPROF ## # ℹ 99,990 more rows # Selecionando todas as colunas num intervalo de colunas (inclusive) select(tb_ibama, UF_REMETENTE:TIPO_DESTINO) ## # A tibble: 100,000 × 3 ## UF_REMETENTE MUNICÍPIO_REMETENTE TIPO_DESTINO ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 PA Santarém EMPREENDIMENTO_CEPROF ## 2 PA Alenquer EMPREENDIMENTO_CEPROF ## 3 PA Rurópolis EMPREENDIMENTO_CEPROF ## 4 PA Tucuruí EMPREENDIMENTO_IBAMA ## 5 PA Paragominas EMPREENDIMENTO_CEPROF ## 6 PA Breu Branco EMPREENDIMENTO_CEPROF ## 7 PA Benevides EMPREENDIMENTO_IBAMA ## 8 PA Tucuruí EMPREENDIMENTO_IBAMA ## 9 PA Moju EMPREENDIMENTO_IBAMA ## 10 PA Santarém EMPREENDIMENTO_CEPROF ## # ℹ 99,990 more rows # Selecionando todas as clunas exceto aqueles em um intervalo (inclusive) select(tb_ibama, -(UF_REMETENTE:TIPO_DESTINO)) ## # A tibble: 100,000 × 13 ## TIPO_GF STATUS_GF CEPROF_DESTINATÁRIO UF_DESTINATÁRIO MUNICÍPIO_DESTINATÁRIO N_AUTORIZAÇÃO PROCESSO EMISSAO ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 GF1 RECEBIDO XXXX PA São Miguel do Guamá 272866/2016 2015/0000… 42752 ## 2 GF1 RECEBIDO XXXX PA Tailândia 272870/2016 2014/0000… 42789 ## 3 GF1 RECEBIDO XXXX PA Rurópolis 272887/2016 2013/0000… 42762 ## 4 GF3I RECEBIDO &lt;NA&gt; BA Macaúbas &lt;NA&gt; &lt;NA&gt; 42900 ## 5 GF3 RECEBIDO XXXX PA Paragominas &lt;NA&gt; &lt;NA&gt; 42746 ## 6 GF2 RECEBIDO XXXX PA Breu Branco 3108/2016 2009/1016 42899 ## 7 GF3I RECEBIDO &lt;NA&gt; BA Vera Cruz &lt;NA&gt; &lt;NA&gt; 42808 ## 8 GF3I RECEBIDO &lt;NA&gt; BA Feira de Santana &lt;NA&gt; &lt;NA&gt; 42860 ## 9 GF3I RECEBIDO &lt;NA&gt; SE Aracaju &lt;NA&gt; &lt;NA&gt; 42790 ## 10 GF1 RECEBIDO XXXX PA Santa Bárbara do Pará 272861/2016 2015/0000… 42798 ## # ℹ 99,990 more rows ## # ℹ 5 more variables: NOME_CIENTÍFICO &lt;chr&gt;, PRODUTO &lt;chr&gt;, VOLUME &lt;dbl&gt;, UNID &lt;chr&gt;, PRECO_TOTAL &lt;dbl&gt; DICA: Existem helper functions que podemos usar dentro de select(). São funções que lembram o funcionamento de uma regular expression (conceito que veremos no Módulo 3) para identificarmos nomes de colunas que atendem a determinado critério. São muito úteis com grandes datasets: starts_with(), ends_with(), matches() e contains(). Vamos por exemplo selecionar todas as colunas que começam com UF: select(tb_ibama, starts_with(&quot;UF&quot;)) ## # A tibble: 100,000 × 2 ## UF_REMETENTE UF_DESTINATÁRIO ## &lt;chr&gt; &lt;chr&gt; ## 1 PA PA ## 2 PA PA ## 3 PA PA ## 4 PA BA ## 5 PA PA ## 6 PA PA ## 7 PA BA ## 8 PA BA ## 9 PA SE ## 10 PA PA ## # ℹ 99,990 more rows select() pode ser usada inclusive para renomear variáveis: select(tb_ibama, MUN_REMETENTE = MUNICÍPIO_REMETENTE) ## # A tibble: 100,000 × 1 ## MUN_REMETENTE ## &lt;chr&gt; ## 1 Santarém ## 2 Alenquer ## 3 Rurópolis ## 4 Tucuruí ## 5 Paragominas ## 6 Breu Branco ## 7 Benevides ## 8 Tucuruí ## 9 Moju ## 10 Santarém ## # ℹ 99,990 more rows A nova variável será chamada MUN_REMETENTE e receberá toda a informação da original MUNICÍPIO_REMETENTE. No entanto, select() “abandona” todas as demais variáveis quando você faz uma renomeação. O melhor então é usar rename(): rename(tb_ibama, MUN_REMETENTE = MUNICÍPIO_REMETENTE) ## # A tibble: 100,000 × 16 ## TIPO_GF STATUS_GF UF_REMETENTE MUN_REMETENTE TIPO_DESTINO CEPROF_DESTINATÁRIO UF_DESTINATÁRIO ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 GF1 RECEBIDO PA Santarém EMPREENDIMENTO_CEPROF XXXX PA ## 2 GF1 RECEBIDO PA Alenquer EMPREENDIMENTO_CEPROF XXXX PA ## 3 GF1 RECEBIDO PA Rurópolis EMPREENDIMENTO_CEPROF XXXX PA ## 4 GF3I RECEBIDO PA Tucuruí EMPREENDIMENTO_IBAMA &lt;NA&gt; BA ## 5 GF3 RECEBIDO PA Paragominas EMPREENDIMENTO_CEPROF XXXX PA ## 6 GF2 RECEBIDO PA Breu Branco EMPREENDIMENTO_CEPROF XXXX PA ## 7 GF3I RECEBIDO PA Benevides EMPREENDIMENTO_IBAMA &lt;NA&gt; BA ## 8 GF3I RECEBIDO PA Tucuruí EMPREENDIMENTO_IBAMA &lt;NA&gt; BA ## 9 GF3I RECEBIDO PA Moju EMPREENDIMENTO_IBAMA &lt;NA&gt; SE ## 10 GF1 RECEBIDO PA Santarém EMPREENDIMENTO_CEPROF XXXX PA ## # ℹ 99,990 more rows ## # ℹ 9 more variables: MUNICÍPIO_DESTINATÁRIO &lt;chr&gt;, N_AUTORIZAÇÃO &lt;chr&gt;, PROCESSO &lt;chr&gt;, EMISSAO &lt;int&gt;, ## # NOME_CIENTÍFICO &lt;chr&gt;, PRODUTO &lt;chr&gt;, VOLUME &lt;dbl&gt;, UNID &lt;chr&gt;, PRECO_TOTAL &lt;dbl&gt; 2.2.4 Adicionando novas colunas com mutate() Além de selecionar conjuntos de colunas existentes, é geralmente útil adicionar novas colunas que são funções de colunas já presentes no tibble/dataframe. Veja um exemplo com mutate(), onde queremos calcular o preço por unidade de volume: mutate(tb_ibama, preco_unidade = PRECO_TOTAL / VOLUME, ) ## # A tibble: 100,000 × 17 ## TIPO_GF STATUS_GF UF_REMETENTE MUNICÍPIO_REMETENTE TIPO_DESTINO CEPROF_DESTINATÁRIO UF_DESTINATÁRIO ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 GF1 RECEBIDO PA Santarém EMPREENDIMENTO_CEPROF XXXX PA ## 2 GF1 RECEBIDO PA Alenquer EMPREENDIMENTO_CEPROF XXXX PA ## 3 GF1 RECEBIDO PA Rurópolis EMPREENDIMENTO_CEPROF XXXX PA ## 4 GF3I RECEBIDO PA Tucuruí EMPREENDIMENTO_IBAMA &lt;NA&gt; BA ## 5 GF3 RECEBIDO PA Paragominas EMPREENDIMENTO_CEPROF XXXX PA ## 6 GF2 RECEBIDO PA Breu Branco EMPREENDIMENTO_CEPROF XXXX PA ## 7 GF3I RECEBIDO PA Benevides EMPREENDIMENTO_IBAMA &lt;NA&gt; BA ## 8 GF3I RECEBIDO PA Tucuruí EMPREENDIMENTO_IBAMA &lt;NA&gt; BA ## 9 GF3I RECEBIDO PA Moju EMPREENDIMENTO_IBAMA &lt;NA&gt; SE ## 10 GF1 RECEBIDO PA Santarém EMPREENDIMENTO_CEPROF XXXX PA ## # ℹ 99,990 more rows ## # ℹ 10 more variables: MUNICÍPIO_DESTINATÁRIO &lt;chr&gt;, N_AUTORIZAÇÃO &lt;chr&gt;, PROCESSO &lt;chr&gt;, EMISSAO &lt;int&gt;, ## # NOME_CIENTÍFICO &lt;chr&gt;, PRODUTO &lt;chr&gt;, VOLUME &lt;dbl&gt;, UNID &lt;chr&gt;, PRECO_TOTAL &lt;dbl&gt;, preco_unidade &lt;dbl&gt; mutate() nos permite ainda nos referir a colunas que acabamos de criar no mesmo comando. Vamos salvar esta alteração em um novo tibble, chamado tb_ibama2 tb_ibama2 &lt;- mutate(tb_ibama, preco_unidade = PRECO_TOTAL / VOLUME, preco_unidade_vezes_1000 = preco_unidade * 1000 ) Se só nos interessarem as novas variáveis, usaríamos transmute(): transmute(tb_ibama, preco_unidade = PRECO_TOTAL / VOLUME, preco_unidade_vezes_1000 = preco_unidade * 1000 ) ## # A tibble: 100,000 × 2 ## preco_unidade preco_unidade_vezes_1000 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 167. 166928. ## 2 167. 166869. ## 3 180. 180123. ## 4 492. 492249. ## 5 167. 167010. ## 6 68.9 68890. ## 7 356. 356196. ## 8 356. 356076. ## 9 796. 796081. ## 10 207. 207400. ## # ℹ 99,990 more rows 2.2.5 Modificando entradas com mutate() ou transmute() + case_when() case_when() é uma função do pacote dplyr que nos permite modificar as variáveis a partir de uma sequência de condições que devem ser respeitadas. SE CONDIÇÃO1 VERDADEIRA ~ FAÇA TAL COISA; SENÃO ~ FAÇA OUTRA COISA Ela substitui as estruturas condicionais nativas do R (função ifelse()) e é inspirada na declaração equivalente em SQL CASE WHEN. Os argumentos da função case_when() obedecem à seguinte estrutura: operação condicional ~ novo valor. No lado esquerdo do ~, você tem a comparação a ser feita. No lado direito, temos o novo valor a ser atribuído caso o resultado da comparação seja TRUE. Você pode tratar, inclusive, mais de uma condição, desde que parta do caso mais específico para o mais geral. case_when( condição1 ~ &quot;novo_valor1&quot;, condição2 ~ &quot;novo_valor2&quot;, condição3 ~ &quot;novo_valor3&quot;, TRUE ~ &quot;valor para os demais casos não atendidos pelas condições acima&quot; ) Geralmente, no contexto de análise de dados com dplyr, utilizamos case_when() dentro de uma função mutate() ou transmute (que traz a apenas a nova coluna criada), uma vez que pretendemos alterar as entradas de uma coluna, alterando, portanto, a própria coluna. No tibble tb_ibama2, amos criar uma nova coluna de caracteres chamada nivel_preco, em que classificaremos um preco em: alto se preco_unidade &gt; 500; baixo se preco_unidade &lt; 300 ou razoavel nos demais casos: transmute(tb_ibama2, nivel_preco = case_when( preco_unidade &gt; 500 ~ &quot;alto&quot;, preco_unidade &lt; 300 ~ &quot;baixo&quot;, TRUE ~ &quot;razoável&quot; )) ## # A tibble: 100,000 × 1 ## nivel_preco ## &lt;chr&gt; ## 1 baixo ## 2 baixo ## 3 baixo ## 4 razoável ## 5 baixo ## 6 baixo ## 7 razoável ## 8 razoável ## 9 alto ## 10 baixo ## # ℹ 99,990 more rows DICA: Se os valores das colunas recém criadas forem exibidos em notação exponencial (científica), execute o código abaixo para forçar a exibição das casas decimais em modo convencional e depois imprima novamente as colunas. # scipen é uma espécie de penalização para a utilização de notação em valores exponenciais # valores positivos penalizam a exibição em notação exponencial # valores negativos penalizam a exibição em notação fixa/regular options(scipen=999) 2.2.6 Sumarizando valores com summarise() O último “verbo” de dplyr é summarise() (ou summarize). Ele colapsa um tibble/dataframe em uma única linha. summarise(tb_ibama2, preco_total_medio = mean(PRECO_TOTAL, na.rm = TRUE) ) ## # A tibble: 1 × 1 ## preco_total_medio ## &lt;dbl&gt; ## 1 2138. DICA: O parâmetro na.rm = TRUE dentro da função mean() serve para que esta desconsidere os valores falatantes (NA) ao calcular a média. Do contrário, na existência de missing values NA, a função sempre retornará NA. Isso também vale para outras funções matemáticas de funcionamento vetorizado, como sum(), por exemplo. Dependendo do seu objetivo, pode ser mais útil utilizar o “verbo” group_by() que veremos mais a frente. Com ele poderemos calcular o preço médio por categoria, i.e. por Estado, Município, etc. 2.2.7 Estrutura do dplyr Note que a sintaxe e funcionamento de todos os verbos de dplyr apresentados até aqui são bem similares: o primeiro argumento é um tibble/dataframe; os argumentos subsequentes descrevem o que fazer com os dados. Podemos nos referir às colunas do tibble/dataframe diretamente sem a necessidade de usar $ ou indexação por []. o resultado é um novo tibble/dataframe. Juntas, essas propriedades facilitam encadear múltiplos passos simples para alcançar um resultado complexo. O restante do que dplyr faz, vem de aplicar as 5 funções que vimos até aqui a diferentes tipos de dados. Ao invpes de trabalharmos com dados desagregados, vamos passar a trabalhar agora com dados agrupados por uma ou mais variáveis. 2.2.7.1 Operações agrupadas Os verbos de dplyr tornam-se ainda mais poderosos quando os aplicamos a grupos de observações dentro de um conjunto de dados. Fazemos isso com a função group_by(). Ela “quebra” o dataset em grupos específicos de linhas. No início, não vemos qualquer alteração. É como se elas ficassem em segundo plano. No entanto, ao aplicarmos algum dos verbos principais no dataset “alterado” por group_by, eles automaticamente serão aplicados por grupo ou “by group”. O uso de agrupamento afeta o resultado dos verbos principais da seguinte forma: select() agrupado é o mesmo que não agrupado, exceto pelo fato que as variáveis de agrupamento são sempre preservadas. arrange() agrupado é mesmo que não agrupado, a não ser que usemos .by_group = TRUE, caso em que ordena primeiro pelas variáveis de agrupamento; mutate() e filter() são bastante úteis em conjunto com window functions (como rank() ou min(x) == x) (Ver vignette de “window-functions” do dplyr); summarise() calcula o sumário para cada grupo. No exemplo a seguir, nós separamos o dataset por PRODUTO, contando o número de registros para cada um dos produtos (count = n()), computando a preço médio por produto (preco_medio_produto = mean(preco_unidade, na.rm = TRUE)). by_produto &lt;- group_by(tb_ibama2, PRODUTO) preco_medio_produto &lt;- summarise( by_produto, count = n(), pmp = mean(preco_unidade, na.rm = TRUE) ) Note que summarise() é normalmente utilizada com aggregate functions, as quais recebem um vetor de valores e retornam um único número. Há muito exemplos úteis do base R que podem ser utilizados, como min(), max(), mean(), sum(), sd(), median(), etc. dplyr fornece mais algumas outras bem úteis: n(): número de observações no grupo atual; n_distinct(x): número de valores únicos em x; first(x), last(x) e nth(x, n) funcionam de forma similar a x[1], x[length(x)] e x[n], mas nos dão maior controle sobre resultado caso algum valor seja missing. Veja um exemplo em que usamos estas funções para encontrar o número de produtos distintos que seguem para cada possível destino e quantidade total de produtos que o Município recebe: destinos &lt;- group_by(tb_ibama2, MUNICÍPIO_DESTINATÁRIO) summarise(destinos, n_produtos_distintos = n_distinct(PRODUTO), qte_total_produtos = n() ) ## # A tibble: 1,452 × 3 ## MUNICÍPIO_DESTINATÁRIO n_produtos_distintos qte_total_produtos ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Abaetetuba 1 1 ## 2 Abaiara 5 15 ## 3 Acajutiba 1 1 ## 4 Acaraú 3 3 ## 5 Acopiara 4 12 ## 6 Adamantina 1 1 ## 7 Afogados da Ingazeira 8 29 ## 8 Afuá 3 59 ## 9 Agrestina 8 45 ## 10 Aguaí 5 6 ## # ℹ 1,442 more rows Quando agrupamos mais de uma variável, cada summarise() que executamos, elimina um nível do agrupamento. Exemplo: by_uf_mun_dest &lt;- group_by(tb_ibama2, UF_DESTINATÁRIO, MUNICÍPIO_DESTINATÁRIO) (qte_produtos_por_mun_dest &lt;- summarise(by_uf_mun_dest, qte = n())) ## `summarise()` has grouped output by &#39;UF_DESTINATÁRIO&#39;. You can override using the `.groups` argument. ## # A tibble: 1,480 × 3 ## # Groups: UF_DESTINATÁRIO [23] ## UF_DESTINATÁRIO MUNICÍPIO_DESTINATÁRIO qte ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 AL Arapiraca 633 ## 2 AL Atalaia 44 ## 3 AL Barra de São Miguel 1 ## 4 AL Batalha 14 ## 5 AL Cacimbinhas 5 ## 6 AL Cajueiro 10 ## 7 AL Campestre 2 ## 8 AL Campo Grande 4 ## 9 AL Canapi 16 ## 10 AL Capela 8 ## # ℹ 1,470 more rows # notar que da descrição &quot;Groups:&quot; do tibble, ou seja, o número de variáveis de agrupamento vai diminuindo. (qte_produtos_por_uf_dest &lt;- summarise(qte_produtos_por_mun_dest, qte = sum(qte))) ## # A tibble: 23 × 2 ## UF_DESTINATÁRIO qte ## &lt;chr&gt; &lt;int&gt; ## 1 AL 2025 ## 2 AM 1 ## 3 BA 4458 ## 4 CE 3172 ## 5 DF 24 ## 6 ES 269 ## 7 GO 418 ## 8 MA 736 ## 9 MG 1573 ## 10 MS 49 ## # ℹ 13 more rows 2.2.7.2 Cuidados com os nomes de variáveis Uma das melhores características do pacote dplyr é que podemos nos referir as variáveis de um tibble ou dataframe como se fossem variáveis regulares (aquelas que estão no Global Environment). No entanto, a sintaxe de referência para nomes de colunas escondem algumas diferenças entre os verbos. Por exemplo, um nome ou valor de coluna passado para select() não tem o mesmo significado do que teria em mutate(). Veja formas equivalentes do ponto de vista de dplyr: select(tb_ibama2, TIPO_GF) ## # A tibble: 100,000 × 1 ## TIPO_GF ## &lt;chr&gt; ## 1 GF1 ## 2 GF1 ## 3 GF1 ## 4 GF3I ## 5 GF3 ## 6 GF2 ## 7 GF3I ## 8 GF3I ## 9 GF3I ## 10 GF1 ## # ℹ 99,990 more rows select(tb_ibama2, 1) ## # A tibble: 100,000 × 1 ## TIPO_GF ## &lt;chr&gt; ## 1 GF1 ## 2 GF1 ## 3 GF1 ## 4 GF3I ## 5 GF3 ## 6 GF2 ## 7 GF3I ## 8 GF3I ## 9 GF3I ## 10 GF1 ## # ℹ 99,990 more rows Se houver uma variável no Global Environment com o mesmo nome de uma coluna de nosso tibble/dataframe, o dplyr dará prioridade à variável que está no tibble. TIPO_GF &lt;- 5 select(tb_ibama2, TIPO_GF) ## # A tibble: 100,000 × 1 ## TIPO_GF ## &lt;chr&gt; ## 1 GF1 ## 2 GF1 ## 3 GF1 ## 4 GF3I ## 5 GF3 ## 6 GF2 ## 7 GF3I ## 8 GF3I ## 9 GF3I ## 10 GF1 ## # ℹ 99,990 more rows Esse comportamento somente se aplica aos nomes “crus” e às chamadas de seleção como select(tibble, var1, var2, var3) ou var1:var3. Em todos os outros casos, os nomes das colunas dos tibbles são preteridas às “variáveis soltas” no Global Environment. var1 &lt;- &quot;UF&quot; select(tb_ibama2, starts_with(var1)) ## # A tibble: 100,000 × 2 ## UF_REMETENTE UF_DESTINATÁRIO ## &lt;chr&gt; &lt;chr&gt; ## 1 PA PA ## 2 PA PA ## 3 PA PA ## 4 PA BA ## 5 PA PA ## 6 PA PA ## 7 PA BA ## 8 PA BA ## 9 PA SE ## 10 PA PA ## # ℹ 99,990 more rows Note que neste útlimo caso, o dplyr olhou para o conteúdo da variável var1 e não para o nome literal da variável. 2.2.8 Usando o Pipe %&gt;% dplyr é funcional no sentido de que os chamados às funções não tem efeitos colaterais. Ou seja, você sempre precisa salvar seus resultados. Isso faz com que não tenhámos um código tão elegante, especialmente quando vamos fazer várias operações, uma de cada vez: # agrupando por UF_DESTINATÁRIO, MUNICÍPIO_DESTINATÁRIO nivel1 &lt;- group_by(tb_ibama2, UF_DESTINATÁRIO, MUNICÍPIO_DESTINATÁRIO) # selecionando apenas colunas PRODUTO, PRECO_TOTAL, preco_unidade nivel2 &lt;- select(nivel1, PRODUTO, PRECO_TOTAL, preco_unidade) # calculando quantidade total de produtos e valor total por MUNICÍPIO_DESTINATÁRIO nivel3 &lt;- summarise(nivel2, qte_total_produtos = n(), valor_total = sum(PRECO_TOTAL, na.rm = TRUE) ) # filtrando Municípios com quantidade de produtos acima de 100 OU # ... valor total acima de R$ 2.000.000,00 nivel4 &lt;- filter(nivel3, qte_total_produtos &gt; 100 | valor_total &gt; 2000000) Note que há muitos resultados intermediários que vamos salvando, quando na verdade só nos interessaria o final. Para resolver isso poderíamos ir chamando uma função dentro da outra: filter( summarise( select( group_by(tb_ibama2, UF_DESTINATÁRIO, MUNICÍPIO_DESTINATÁRIO), PRODUTO, PRECO_TOTAL, preco_unidade ), qte_total_produtos = n(), valor_total = sum(PRECO_TOTAL, na.rm = TRUE) ), qte_total_produtos &gt; 100 | valor_total &gt; 2000000 ) Embora resolva o problema de salvar os objetos intermediários, esta abordagem é difícil de se ler os passos porque a ordem das operações se dá dentro para fora. Então, os argumentos acabam ficando longe da função propriamente dita. Para dar uma solução elegante ao problema, dplyr utiliza o operador pipe %&gt;% do pacote magritrr. x %&gt;% f() equivale a f(x). Então, podemos utilizar esse operador para reescrever múltiplas operações que podemos ler da esquerda para direita e de cima para baixo. É como se cada linha de código funcionasse como um departamento destinto de uma empresa. A produção começa na primeira linha. Terminada as alterações nesse primeiro departamento, o produto (dados) ainda inacabado é “jogado” para o departamento de baixo por meio do pipe, onde a produção continua. De lá segue para o próximo de partamento, e assim segue até que todas as alterações nos dados tenham sido realizadas. tb_ibama2 %&gt;% group_by(UF_DESTINATÁRIO, MUNICÍPIO_DESTINATÁRIO) %&gt;% select(PRODUTO, PRECO_TOTAL, preco_unidade) %&gt;% summarise( qte_total_produtos = n(), valor_total = sum(PRECO_TOTAL, na.rm = TRUE) ) %&gt;% filter(qte_total_produtos &gt; 100 | valor_total &gt; 2000000) ## Adding missing grouping variables: `UF_DESTINATÁRIO`, `MUNICÍPIO_DESTINATÁRIO` ## `summarise()` has grouped output by &#39;UF_DESTINATÁRIO&#39;. You can override using the `.groups` argument. ## # A tibble: 71 × 4 ## # Groups: UF_DESTINATÁRIO [11] ## UF_DESTINATÁRIO MUNICÍPIO_DESTINATÁRIO qte_total_produtos valor_total ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 AL Arapiraca 633 1047426. ## 2 AL Maceió 331 781763. ## 3 BA Cruz das Almas 101 174860. ## 4 BA Feira de Santana 389 591693. ## 5 BA Juazeiro 256 298826. ## 6 BA Paulo Afonso 279 211367. ## 7 BA Santo Antônio de Jesus 162 259659. ## 8 BA Vitória da Conquista 157 295449. ## 9 CE Caucaia 151 332010. ## 10 CE Fortaleza 348 1225146. ## # ℹ 61 more rows DICA: Note que o nome do tibble ou dataframe só precisa ser informado uma única vez logo ao início do processo. 2.2.9 Referências da seção Wickham H.; François, R.; Henry, L.; Müller K. (2019). dplyr: A Grammar of Data Manipulation. R package version 0.8.1. URL https://CRAN.R-project.org/package=dplyr. Wickham H.; François, R.; Henry, L.; Müller K. (2020). dplyr vignette: Introduction. URL http://dplyr.tidyverse.org. Wickham, H.; Grolemund, G. (2016). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. O’Reilly Media. december 2016. 522 pages. Disponível em: https://www.r4ds.co.nz. 2.2.10 Exercícios Importe a tabela selecionada contendo uma projeção do Censo Escolar Agregado por número de alunos por etapa de ensino para os anos de 2020 e 2021 . Qual é o número de alunos por série de ensino em 2019? Escreva uma nova tabela txt ou csv com esses dados. Agrupe os dados pelos UFs de SP, RJ e MG e salve uma tabela separada (txt ou csv) para cada um dos agrupamentos. DICA: Pesquise sobre como separar dataframes por grupos com dplyr e como indexar listas. Identifique o estado com menor número de alunos projetado para 2020. Crie e salve uma nova tabela contendo o número de escolas por UF. 2.3 Gráficos com ggplot2 Nesta seção veremos como fazer gráficos sofisticados no R. Serão apenas noções básicas, uma vez que a ggplot2 propicia um controle total de quase todos os aspectos de um gráfico ao usuário. No entanto, já serão ferramentas sufcientes para confecionar e personalizar diversos gráficos no R. A quantidade de tipos de gráficos que podemos fazer com ggplot2 é imensurável. A ideia é enterdermos os conceitos básicos e estruturais do pacote para depois caminharmos com nossas próprias pernas. 2.3.1 Introdução O pacote ggplot2 cria gráficos utilizando camadas de atributos, utilizando a chamada gramática de gráficos. Esta gramática permite construir gráficos componente por componente ao invés de termos que editar gráficos “pré-fabricados” como ocorre no base R e em todas as outras bibliotecas de linguagens usadas para Data Science, como matplotlib e seaborn de Python, por exemplo. Nós não precisamos conhecer a gramática para começar a produzir gráficos com ggplot2. Todavia, ao compreendermos a estrutura da gramática de gráficos, podemos: construir gráficos a partir de conceitos (do que desejamos fazer) ao invés de termos que lembrar comandos e opções; conceber novos e melhorados gráficos. O ggplot2, embora tenha surgido antes do tidyverse, também é um dos pacotes que do core deste meta-packge. Ele foi escrito por Hadley Wickham, o qual publicou o livro intitulado “ggplot2 Elegant Graphics for Data Analysis”. O sucesso de ggplot2 é tão expressivo que foram feitos APIs (Application Programming Interface) para que as funcionalidades do pacote pudessem ser empregadas em outra s linguagens, como Python por exemplo. 2.3.2 A gramática de gráficos A gramática de gráficos foi um conceito desenvolvido por Leland Wilkinson em 1999 e publicado por ele em The Grammar of Graphics em 2005. Essa gramática define regras para estruturar elementos matemáticos e estéticos (aesthetics) em um gráfico propriamente dito. ggplot2 é escrito sob as regras desta gramática. 2.3.2.1 Estrutura da gramática de gráficos no ggplot2: data dados que contém as variáveis a serem plotadas ; variáveis a serem retratadas no gráfico; variáveis a serem mapeadas para os aesthetics (elementos perceptíveis) do gráfico; Geoms (formas geométricas) objetos e formas do gráfico (barras, pontos, linhas, etc) Stats transformações estatísticas , geralmente para sumarizar dados (média, variância, mediana, etc) Scales define quais elementos estéticos (aesthetics) do gráfico serão mapeados para as variáveis (ex: que cores serão mapeadas a quais valores) Coordinate Systems define como os dados serão mapeados para o plano/área do gráfico (Cartesiano, Polar, etc) Facetting divide os dados em subconjuntos para criar multiplas variações do mesmo gráfico (ex: gráficos em painel) Todos esses elementos são tratados como layers e podem ser adiconadas a parte principal do gráfico utilizando-se o sinal +. Neste curso, veremos de forma mais detalhada os elementos data, aesthetics, stats e facetting e o que significa cada um desses elementos na estrutura da gramática de gráficos. Vamos utilizar dois datasets: o de produção madeireira disponibilizado pelo IBAMA e um novo, contendo uma série histórica modificada do censo escolar agregado do Instituto de Pesquisas Educacionais Anísio Teixeira (INEP). Os dados contém o número de estudantes por série de ensino, escola, munícipio e outras variáveis para o período compreendido entre 2007 e 2019, apenas para os estados do Espírito Santo, Mato Grosso do Sul e Roraima. Como o arquivo do Censo Escolar está no formato .csv pt-br (separado por ;), podemos utilizar a função read_csv2() do pacote readr. library(readr) # para ler os dados library(magrittr) # vamos usar pipe %&gt;% library(ggplot2) # para fazer os gráficos # leitura tb_censo_escolar &lt;- read_csv2(file=&quot;https://raw.githubusercontent.com/allanvc/book_IADR-T/master/datasets/tab_censo_sample_ES_MS_RR.csv&quot;) Caso, você não possua mais a tb_ibama2 em sua sessão do R, carregue a tabela original e fça novamente as alterações que fizemos nas seções anteriores library(dplyr) tb_ibama &lt;- read_csv(file=&quot;https://raw.githubusercontent.com/allanvc/book_IADR-T/master/datasets/PA%20GF%202017%20jan-jun_editada.csv&quot;, col_types = cols( X1 = col_double(), TIPO_GF = col_character(), STATUS_GF = col_character(), UF_REMETENTE = col_character(), MUNICÍPIO_REMETENTE = col_character(), TIPO_DESTINO = col_character(), CEPROF_DESTINATÁRIO = col_character(), UF_DESTINATÁRIO = col_character(), MUNICÍPIO_DESTINATÁRIO = col_character(), N_AUTORIZAÇÃO = col_character(), PROCESSO = col_character(), EMISSAO = col_integer(), NOME_CIENTÍFICO = col_character(), PRODUTO = col_character(), VOLUME = col_double(), UNID = col_character(), PRECO_TOTAL = col_double() ) ) tb_ibama$STATUS_GF[1:50000] &lt;- rep(&quot;NÃO VERIFICADO&quot;, 50000) tb_ibama2 &lt;- mutate(tb_ibama, preco_unidade = PRECO_TOTAL / VOLUME, preco_unidade_vezes_1000 = preco_unidade * 1000 ) 2.3.3 Data (Dados) Os dados utilizados com as funções de ggplot2 DEVEM ser armazenados como um tibble ou dataframe. Há possibilidade, inclusive, de se usar mais de um dataframe em um gráfico. A recomendação é que se defina e se certifique acerca dos tipos das variáveis (numeric, factor, etc) antes de começar a construir um gráfico 2.3.4 A função ggplot() Os dados que serão usados para plotagem serão especificados dentro da função ggplot(). Note que é ggplot() e não ggplot2(). O nosso data.frame ou tibble será sempre o primeiro argumento desta função. Um outro argumento a ser passado para a função ggplot() são os aesthetics, utilizando a função auxiliar aes() que mapeia as variáveis dos dados para os elementos gráficos perceptíveis (estéticos), como por exemplo a posição nos eixos dos gráficos, a definição de cores por categorias, etc. Qualquer função subsequente vai herdar os dados e os aesthetics de ggplot(), a não ser que estes parâmetros sejam sobrescritos em outra camada. Para encadear outras funções à função ggplot(), usamos sempre +. 2.3.5 Aesthetics (elementos estéticos dos gráficos) Variáveis são mapeadas para os aesthetics, o que significa que são traduzidas para os elementos estéticos do gráfico. A função aes(), como já vimos, é quem faz esse mapeamento. Ela também pode ser especificada dentro de outras camadas que compõem o gráfico, como geoms ou stats, por exemplo . Os aesthetics mais utilizados são: x - posição no eixo x; y - posição no eixo y; color ou colour - “cor de fora” ou do contorno do objeto; fill - “cor de dentro” do objeto; alpha - nível transparência do gráfico; shape - forma dos marcadores (pontos, triângilos, cruz, etc); size - tamanho (do raio) dos objetos. 2.3.6 Exemplos para aesthetics Para fazermos um gráfico, primeiro precisamos indicar os dados e fazer o mapeamento das variáveis aos aesthetics. Isso reserva uma área de gráfico a ser utilizada. options(scipen= 999) # para evitar a exibição em notação exponencial # ggplot(data=tb_ibama2, mapping = aes(x=VOLUME, y=PRECO_TOTAL)) # OU tb_ibama2 %&gt;% ggplot(data=tb_ibama2, mapping = aes(x=VOLUME, y=PRECO_TOTAL)) Vejamos um primeiro exemplo para o cruzamento entre VOLUME vs PRECO_TOTAL. tb_ibama2 %&gt;% ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL))+ geom_point() Note que não houve a necessidade de re-especificar os argumentos data e aes() para a função geom_point(). Poderíamos melhorar nosso gráfico adicionando cores dentro de aes(). Isso acrescentaria mais informação. Poderíamos atribuir cores diferentes para cada tipo de destino das toras de madeira: tb_ibama2 %&gt;% ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL))+ geom_point(aes(color=TIPO_DESTINO)) # ou # tb_ibama2 %&gt;% # ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL, color=TIPO_DESTINO))+ # geom_point() Podemos atribuir diferentes intensidades aos pontos, dependendo do valor de uma terceira variável (de preferência contínua entre 0 e 1), utilizando o argumento alpha. Como no nosso dataset do IBAMA, não temos tal variável, vamos criar uma variável contínua por meio da simulação de valores dentro de uma distribuição de probabilidade Normal (\\(N(0,1)\\)): # simulando valores tb_ibama2 &lt;- tb_ibama2 %&gt;% mutate(quant_sim = rnorm(n()), prob_sim = pnorm(quant_sim) ) tb_ibama2 %&gt;% ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL, alpha=prob_sim))+ geom_point() Neste nosso caso, esse gráfico não é muito útil porque temos vários pontos sobrepostos e isto dificulta a percepção de como as cores estão variando. No entanto, serve para ilustrar essa possibilidade com ggplot2. Uma melhor forma de demonstrar os diferentes tipos de destino seria utilizar diferentes formas (argumento shape): tb_ibama2 %&gt;% ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL, shape=TIPO_DESTINO))+ geom_point() 2.3.6.1 Mapping vs Setting aesthetics Nos exemplos anteriores, poderíamos optar por usar apenas uma única cor ou um único shape que não fosse o padrão de “bolinha” na cor preta. O que deveríamos fazer então, ao invés de mapear variáveis para aesthetic, é setar a aesthetic constante. Quando vamos mapear um aesthetic, as variáveis são passadas dentro de aes(); ao passo que quando vamos setar um aesthetic como constante, o valor é passado fora de aes(). Vejamos os exemplos anteriores com um aesthetic constante para cor e shape: tb_ibama2 %&gt;% ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL))+ geom_point(color = &quot;red&quot;) tb_ibama2 %&gt;% ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL))+ geom_point(shape = 2) Note que devemos passar as constantes para geom_point() (fora de aes()) - o a função de objetos geométricos - e não para ggplot(). Veja quantos shapes podemos usar no R: d=data.frame(p=c(0:25,32:127)) ggplot() + scale_y_continuous(name=&quot;&quot;) + scale_x_continuous(name=&quot;&quot;) + scale_shape_identity() + geom_point(data=d, mapping=aes(x=p%%16, y=p%/%16, shape=p), size=5, fill=&quot;red&quot;) + geom_text(data=d, mapping=aes(x=p%%16, y=p%/%16+0.25, label=p), size=3) # http://sape.inf.usi.ch/quick-reference/ggplot2/shape Cuidado ao setar uma aesthetic como constante dentro de aes(), pois isso pode resultar em um comportamento inesperado. tb_ibama2 %&gt;% ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL)) + geom_point(aes(color = &quot;green&quot;)) Embora tenhámos setado a cor como \"green\", o fato de termos feito dentro de aes() faz com que o ggplot 2.3.7 Geoms Geoms são as formas geométricas a serem plotadas nos gráficos, exemplo geom_line(), geom_col(), geom_point(), etc. Eles diferem de um para o outro nos tipos de aesthetics que eles requerem ou entendem. Por exemplo: geom_point() requer aes(x, y), ao passo que geom_bar() requer aes(x) apenas. Para obter ajuda digite ?geom_x. 2.3.8 Exemplos para Geoms geoms para uma variável numérica (contínua de preferência) c &lt;- tb_ibama2 %&gt;% ggplot(mapping = aes(x=quant_sim)) DICA: Note que podemos atribuir o resultado do gráfico a um objeto no R e acrescentar outras layers posteriormente. c + geom_density() c + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. geoms para uma variável numérica discreta # contagem tb_ibama2 %&gt;% ggplot(mapping = aes(x=TIPO_GF))+ geom_bar() geoms para duas variáveis (contínuas) geom_point() tambpem pode ser usado neste caso: e &lt;- tb_ibama2 %&gt;% ggplot(mapping=aes(x=VOLUME, y=PRECO_TOTAL)) e + geom_point() geoms para duas variáveis (uma qualitativa e uma numérica) Os gráficos abaixo são ideais para verificar como os valores se distribuem, separando-os em difernetes categorias. f &lt;- tb_ibama2 %&gt;% ggplot(mapping=aes(TIPO_GF, quant_sim)) f + geom_boxplot() f + geom_violin() geoms para gráficos de linha Neste ponto, vamos trocar de dataset. Passaremos a utilizar agora o dataset tb_censo_escolar. Faremos algumas transformações com dplyr e seguiremos direto para o plot usando pipe %&gt;%. tb_censo_escolar %&gt;% group_by(SG_UF, NU_ANO_CENSO) %&gt;% summarise(QTD_TOTAL = sum(QTD_ALUNOS, na.rm = TRUE)) %&gt;% ggplot(mapping=aes(NU_ANO_CENSO, QTD_TOTAL, colour=SG_UF))+ geom_line() ## `summarise()` has grouped output by &#39;SG_UF&#39;. You can override using the `.groups` argument. No caso de gráficos de linhas, ao invés de usar cores diferentes, poderíamos ainda alterar o tipo de linha conforme as categorias de uma 3ª variável, por meio do argumento linetype: tb_censo_escolar %&gt;% group_by(SG_UF, NU_ANO_CENSO) %&gt;% summarise(QTD_TOTAL = sum(QTD_ALUNOS, na.rm = TRUE)) %&gt;% ggplot(mapping=aes(NU_ANO_CENSO, QTD_TOTAL, linetype=SG_UF))+ geom_line() ## `summarise()` has grouped output by &#39;SG_UF&#39;. You can override using the `.groups` argument. DICA: Há também outros geoms que você encontrará na página de ajuda. 2.3.8.1 Positions Um aspecto dos gráficos de ggplot2 que não chega a ser uma layer, mas que será importante de observarmos diz respeito a ajustes de posição. Elas serão muito importantes para gráficos de de barras com duas variáveis. Os ajustes de posição definirão como os geoms se localizam no gráfico, de modo que não ocupem o mesmo espaço. No exemplo do gráfico de barras, podemos fazer gráficos de barras justapostas ou empilhadas. -position=\"stacked é o ajuste padrão de geom_point(). Ela coloca cada objeto na posição exata do contexto do gráfico. No caso de gráficos de barras, teríamos barras acumuladas (stacked): # tb_censo_escolar %&gt;% # ggplot(mapping=aes(x=SG_UF, fill=factor(CO_ETAPA_ENSINO)))+ # geom_bar(position=&quot;stack&quot;) # precisa passar CO_ETAPA_ENSINO como factor, senao ele lê como numerica tb_censo_escolar %&gt;% ggplot(mapping=aes(x=SG_UF, fill=factor(NU_ANO_CENSO)))+ geom_bar(position=&quot;stack&quot;) # ou simplemente geom_bar() DICA: Note que forçamos a variável NU_ANO_CENSO como um factor, para que o R a trate como uma variável categórica e não como uma data para realizar a plotagem. Um factor é uma abstração que o R faz para armazenas variáveis categóricas de mod mais eficiente na memória do computador. Para cada valor ele cria um level numérico. É muito mais eficiente guardar um número do que um nome ou uma data, por exemplo. position = “dodge” coloca objetos sobrepostos um ao lado de outro. Nesse caso, teremos barras justapostas: gg_barras &lt;- tb_censo_escolar %&gt;% ggplot(mapping=aes(x=SG_UF, fill=factor(NU_ANO_CENSO)))+ geom_bar(position=&quot;dodge&quot;) DICA: Se voce quiser inverter as coordenadas do gráfico, pode fazer isso trocando os parâmetros x e y e em aes(), ou utilizando a função coord_flip(): gg_barras + coord_flip() position=“fill” também empilhará os elementos, mas irá normalizar a altura de todas as barras para que fiquem na mesma escala. Isso torna mais fácil comparar as proporções entre os grupos: tb_censo_escolar %&gt;% ggplot(mapping=aes(x=SG_UF, fill=factor(NU_ANO_CENSO)))+ geom_bar(position=&quot;fill&quot;) position=“jitter” é útil para gráficos de dispersão, pois hpa um problema muito comum neste tipo de gráfico que é a sobreposição de pontos (overplotting). Com jitter, ggplot2 adiciona um ruído aleatório nas posições de X e Y para que eles não se sobreponham: # mpg %&gt;% # ggplot(mapping=aes(x=displ, y=hwy))+ # geom_point(position=&quot;jitter&quot;) Há outros ajustes de posição bem úteis, como: position=“nudge” afasta os rótulos dos pontos; position=“identity” sobrepõe os elementos uns sobre os outros. 2.3.9 Facetting As facetts em ggplot2 nos permitem criar vários gráficos com base em subconjuntos de dados e plotá-los numma mesma área. É uma técnica muito útil (quando temos variáveis categóricas) e desejamos visualizar o comportamento de diferentes categorias num mesmo gráfico. Há duas funções que permitem criar facetas: facet_wrap() e facet_grid(). Tanto facet_wrap quanto facet_grid permitem a divisão do plot da(s) variável(is) passadas em aes() de acordo com as categorias de uma 3ª ou 3ª e 4ª variáveis. Voltaremos aos exemplos com a base modificada do IBAMA tb_ibama2. Usaremos o log do volume apenas para que os valores dos eixos não se sobreponham. Embora seja possível ajustar isso com as funções de ggplot2, por uma questão de priorização e espaço optamos por não abordar essa funcionalidade nesta apostila. tb_ibama2 %&gt;% ggplot()+ geom_point(mapping=aes(x=log(VOLUME), y=PRECO_TOTAL))+ facet_wrap(TIPO_GF ~ UF_DESTINATÁRIO, nrow = 4) Note acima que podemos definir o número de linhas desejado para plotagem com o argumento nrow ou o número de colunas com ncol e automaticamente o outro argumento será determinado. O símbolo ~ é muito utilizado no R. Nesse casos, isso significa que as variáveis de aes() serão plotadas em função das variáveis STATUS_GF e TIPO_DESTINO, ou seja, para cada combinação das categorias destas variáveis, será feito um plot com as variáveis passadas em aes(). Note que o arranjo das combinações das categorias STATUS_GF e TIPO_DESTINO são passadas nas colunas de gráficos, como se fossem os títulos de cada plot específico. No caso de facet_grid(), a organização do output será um pouco diferente. Será feito, como o próprio nome da função diz, um grid, onde as linhas dirão respeito a uma das variáveis e a coluna à outra variável. É como se fosse uma uma matriz de pequenos gráficos. Como resultado, você verá que há cruzamentos entre as variáveis TIPO_DESTINO e STATUS_GF que resultam em um gráfico vazio por ausência de dados que estejam naquelas respectivas categorias das duas variáveis. No caso anterior, com facte_wrap() isso não ocorre. tb_ibama2 %&gt;% ggplot()+ geom_point(mapping=aes(x=log(VOLUME), y=PRECO_TOTAL))+ facet_grid(TIPO_GF ~ UF_DESTINATÁRIO) 2.3.10 Títulos, rótulos, temas e legendas Há duas formas de alterar títulos e rótulos dos eixos em ggplot2. Você pode optar por ggtitle(\"título do gráfico\"), xlab(\"rótulo eixo x\"), ylab(\"rótulo eixo y\"). Ou então, pode usar labs(). No caso, de usar labs, você pode alterar todos esses campos e outros, como o de legenda dentro da mesma função. Note, no entanto, que o parâmetro que controla o título da legenda muda dependendo do parâmetro dentro de mapping = aes() a partir do qual a legenda foi gerada. Normalmente, a legenda é gerada ou pelos parâmetros colour, fill, size, shape, linetype e alpha. Esses mesmos parâmetros, dependendo do caso, deverão ser passados dentro da função labs() para controlar o título da legenda, como por exemplo: labs(..., shape = \"Título da legenda\"). tb_ibama2 %&gt;% ggplot()+ geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, colour=TIPO_GF))+ labs(title=&quot;Título do gráfico&quot;, x = &quot;Rótulo eixo x&quot;, y = &quot;Rótulo eixo y&quot;, colour = &quot;Título da Legenda&quot;) # OU # tb_ibama2 %&gt;% # ggplot()+ # geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, colour=TIPO_GF))+ # ggtitle(&quot;Título do gráfico&quot;)+ # xlab(&quot;Rótulo eixo x&quot;)+ # ylab(&quot;Rótulo eixo y&quot;)+ # labs(colour=&quot;Título da legenda&quot;) Há ainda funções específicas que também controlam o nome da legenda dependendo do argumento utilizado para gerar a legenda dentro de aes() e também a partir de qual tipo de dados, se contínuos ou discretos. Temos os seguintes casos: scale_GERADOR_discrete(name=\"título da legenda\") scale_GERADOR_continuous(name=\"título da legenda\") Dessa forma, temos: scale_fill_discrete(name=\"título da legenda\"), scale_fill_continuous(name=\"título da legenda\"), scale_colour_discrete(name=\"título da legenda\"), scale_colour_continuous(name=\"título da legenda\"), e assim por diante para os demais argumentos geradores da legenda, como size, linetype, alpha e shape. tb_censo_escolar %&gt;% group_by(SG_UF, NU_ANO_CENSO) %&gt;% summarise(QTD_TOTAL = sum(QTD_ALUNOS, na.rm = TRUE)) %&gt;% ggplot(mapping=aes(NU_ANO_CENSO, QTD_TOTAL, linetype=SG_UF))+ geom_line()+ scale_linetype_discrete(name=&quot;UF&quot;) ## `summarise()` has grouped output by &#39;SG_UF&#39;. You can override using the `.groups` argument. Podemos inclusive ter mais de um argumento de mapping dentro de aes() e podemos controlar as legendas de cada um, adicionando mais uma camada ao gráfico: tb_ibama2 %&gt;% ggplot()+ geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, size=preco_unidade, colour=TIPO_GF))+ ggtitle(&quot;Produção madeireira - Dados IBAMA&quot;)+ xlab(&quot;Volume toras&quot;)+ ylab(&quot;Preço Total toras&quot;)+ scale_size_continuous(name=&quot;Preço por unidade de volume&quot;)+ scale_colour_discrete(name=&quot;Grupo&quot;) 2.3.11 Alterar cores e paleta de cores Você deve ter notado, que na maioria dos gráficos, o ggplot2 utiliza cores padrão da biblioteca para as plotagens. Se você não estiver contente com a paleta de cores padrão utilizada pelo pacote no mapping de suas variáveis, você pode definir manualmente esses cores utilizando uma outra paleta ou outras cores de sua preferência. O modo de alterar a paleta de cores utilizadas em um argumento de mapping dentro de aes() é por meio de funções do tipo scale_GERADOR_manual(), alterando-se o parâmetro values. tb_ibama2 %&gt;% ggplot()+ geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, size=preco_unidade, colour=TIPO_GF))+ ggtitle(&quot;Produção madeireira - Dados IBAMA&quot;)+ xlab(&quot;Volume toras&quot;)+ ylab(&quot;Preço Total toras&quot;)+ scale_size_continuous(name=&quot;Preço por unidade de volume&quot;)+ scale_colour_manual(values=c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;orange&quot;, &quot;yellow&quot;)) Por meio dessas mesmas funções do tipo de funções do tipo scale_GERADOR_manual(), podemos alterar também os rótulos das categorias exibidas na legenda utilizando o argumento labels. tb_ibama2 %&gt;% ggplot()+ geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, size=preco_unidade, colour=TIPO_GF))+ ggtitle(&quot;Produção madeireira - Dados IBAMA&quot;)+ xlab(&quot;Volume toras&quot;)+ ylab(&quot;Preço Total toras&quot;)+ scale_size_continuous(name=&quot;Preço por unidade de volume&quot;)+ scale_colour_manual(values=c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;orange&quot;, &quot;yellow&quot;), labels=c(&quot;tipo1&quot;, &quot;tipo2&quot;, &quot;tipo3&quot;, &quot;tipo4&quot;, &quot;tipo5&quot;)) Como menicionamos várias vezes atpe este ponto do curso, no R existem várias formas de fazer uma mesma coisa. As funções do tipo scale_GERADOR_manual() também permite alterar o título da legenda com o argumento name: tb_ibama2 %&gt;% ggplot()+ geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, size=preco_unidade, colour=TIPO_GF))+ ggtitle(&quot;Produção madeireira - Dados IBAMA&quot;)+ xlab(&quot;Volume toras&quot;)+ ylab(&quot;Preço Total toras&quot;)+ scale_size_continuous(name=&quot;Preço por unidade de volume&quot;)+ scale_colour_manual(values=c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;orange&quot;, &quot;yellow&quot;), labels=c(&quot;tipo1&quot;, &quot;tipo2&quot;, &quot;tipo3&quot;, &quot;tipo4&quot;, &quot;tipo5&quot;), name=&quot;Grupo&quot;) 2.3.12 Área de Plotagem e Tema Como já afirmamos antes, com ggplot2 é possível modificar praticamente todos os parâmetros do seu gráfico. E normalmente há mais de uma forma para se fazer cada uma das alterações. Com a função theme(), é possível controlar desde o tamanho dos elementos do de plotagem do gráfico, passando pelo tamnho do texto dos rótulos e indo até o tamanho dos quadrados ou “bolinhas” da legenda. No entanto, esta será uma pesquisa a ser feita por você. Nesta seção traremos apenas algumas funções do ggplot2 que trazem alguns temas pré-formatados: theme_gray(): plano de fundo cinza e linhas de grid brancas. É como se trouxesse os dados para frente para facilitar comparações; theme_bw(): plano de fundo branco e linhas de grid cinzas. Recomendado para apresentações utilizando projetor; theme_linedraw(): plano de fundo branco e linhas de grid com largura diferenciada. theme_light(): linhas de grid cor cinza claro e com presença de eixos. Parecido como theme_linedraw(); theme_dark(): igual ao theme_light() mas com plano de fundo escuro. Faz linhas coloridas finas se destacarem; theme_minimal(): tema minimalista sem plano de fundo; theme_classic(): tema clássico sem linhas de grid; theme_void(): tema vazio, sem cores de fundo e grid. Recomendado para plots de coordenadas não-usuais ou para desenhos. tb_ibama2 %&gt;% ggplot()+ geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, colour=TIPO_GF))+ labs(title=&quot;Título do gráfico&quot;, x = &quot;Rótulo eixo x&quot;, y = &quot;Rótulo eixo y&quot;, colour = &quot;Título da Legenda&quot;)+ theme_bw() DICA: Estranhamente, ggplot2 alinha o título do gráfico sempre à esquerda. Você pode centralizar o título usando justamente a função theme(), que comentamos mais acima, escrevendo theme(plot.title = element_text(hjust=0.5). 0.5 indica que o título deve ficar no meio do gráfico, conforme alinhamento horizontal especificado (parâmetro hjust). element_text() é uma helper function que serve para controlar aspectos textuais como tamanho (size) e outros parâmetros como o próprio alinhamento horizontal. 2.3.13 Referências da seção Ggplot themes gallery. (2020). DATANOVIA website. URL https://www.datanovia.com/en/blog/ggplot-themes-gallery/ Lin, A. Introduction to ggplot2. Slides. IDRE Statistical Consulting Group. URL https://stats.idre.ucla.edu/stat/data/intro_ggplot2_int/ggplot2_intro_interactive.html#(1) Lopes, J. G. (2019). O guia do ggplot2: como fazer qualquer tipo de gráfico no R. Blog: Explorando o Universo da Ciência de Dados. 05, 2017. URL http://joseguilhermelopes.com.br/o-guia-do-ggplot2-como-fazer-qualquer-tipo-de-grafico-no-r/ Wickham, H.; Grolemund, G. (2016). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. O’Reilly Media. december 2016. 522 pages. Disponível em: https://www.r4ds.co.nz. Wickham, H. (2016). ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. 2016. URL https://ggplot2.tidyverse.org 2.3.14 Exercícios Escolha uma base que você tenha utilizado recentemente no trabalho e a partir da qual você tenha gerado algum gráfico no excel ou outro software. Tente reproduzir dois ou três gráficos utilizando o pacote ggplot2. Não se esqueça de procurar ajuda na internet, principalmente no Stack Overflow e na documentação do pacote, além da apostila. Nos gráficos do exercício 1, há algum aspecto que você gostaria de melhorar? Pesquise sobre como fazê-lo utilizando ggplot2. Sofistique seu gráfico do ggplot2 pro meio da função ggplotly(objeto_criado_com_ggplot2) do pacote plotly. Você pode tornar o seu gráfico interativo e também construir outros gráficos diferentes com plotly. "],["m3.html", " 3 Módulo III 3.1 Acesso a Bancos de Dados relacionais com dbplyr 3.2 Manipulação de dados com Two-table verbs - dplyr 3.3 Análise de dados geográficos no R", " 3 Módulo III 3.1 Acesso a Bancos de Dados relacionais com dbplyr 3.1.1 Introdução O conteúdo desse capítulo foi adaptado a partir da vignette de dbplyr e do artigo Databases using R de Edgar Ruiz, autor do pacote e integrante da RStudio. dbplyr permite combinar a fácil gramática de manipulação de dados fornecida por dplyr e o acesso a bancos de dados relacionais SQL sem precisarmos utilizar efetivamente comandos SQL. Usar bancos de dados é inevitável para aqueles cuja parte do trabalho é analisar dados. A esta altura, como utilizadores da linguagem R, o instinto nos leva a adotar um approach com as bases de dados do mesmo modo com o qual faríamos a leitura de um arquivo de dados .txt ou .csv: nos tentaríamos ler os dados todos de uma vez ou partes dele até atpe formar todo o dataset. O objetivo seria “voltar” ao banco de dados o mínimo possível, de modo que para isso, nossas queries extrairiam o máximo de dados possível. Depois disso, nós passaríamos vários ciclos analisando aqueles dados salvos na memória de nosso computador. Seguiríamos mais ou menos o seguinte esquema: Fonte: Databases using R, Edgar Ruiz Essa abordagem tem alguns problemas: o volume de dados com que teríamos que trabalhar seria muito grande. Por isso, passaríamos alguns momentos pensando em como minimizar o consumo de recursos e o tempo para chegarmos ao subset dos dados que realmente precisamos para trabalhar; para economizar recursos, optaríamos por utilizar diretamente um cliente externo de SQL, trabalhar os dados o máximo possível para então extrairmos os que nos interessam e só depois utilizar o R; precisaríamos conhecer a fundo SQL para fazermos o máximo de consultas possível usando um “client” do SQL Server por exemplo. Salvaríamos os diferentes scripts para que conseguíssemos repetir as consultas novamente; Qual seria então a melhor abordagem? Fonte: Databases using R, Edgar Ruiz Com dbplyr, a tarefa de acessar bancos de dados relacionais seria EXTREMAMENTE otimizada, porque: 1º) Você não precisa conhecer sintaxe de SQL para acessar os dados. Basta saber R e ter uma leve noção de SQL e você já poderá fazer um número considerável de manipulações nos dados; 2º) Você somente precisará do RStudio e não mais de um cliente externo de SQL para fazer as queries; 3º) Os códigos que você precisaria na primeira abordagem caírão pela metade com a segunda 4º) Ao invés de passar horas pensando em qual base de dados você realmente precisa importar, poderemos analisar os dados dentro do servidor SQL; 5º) Ao invés de usar memória do seu computador, você vai usar a engine do servidor SQL, porque dbplyr em conjunto com dplyr vai enviar as queries para o servidor; Manipular dados com comandos de R (e mais ainda com dplyr) é muito mais fácil do que manipular os dados com comandos de SQL. Então, você poderá investigar e manipular os dados de forma muito mais fácil apenas com R para só ao final salvar o resultado no seu computador Antes de começarmos é necessário que você instale e carregue os seguintes pacotes: DBI e dbplyr. DBI é um backend que permite ao dplyr se comunicar com vários tipos de bancos de dados SQL utilizando o mesmo código. No entanto, ao instalarmos e carregarmos dbplyr automaticamente também o será o pacote DBI. # install.packages(&quot;dbplyr&quot;) library(dbplyr) Além de dbplyr (e DBI), nós precisaremos de um backend ou driver específico para o tipo de servidor SQL que vamos acessar. Os mais comuns são: RMySQL conecta a MySQL e MariaDB; RPostgreSQL conecta a Postgres e Redshift; RSQLite incorpora uma base de SQLite embutida (muito útil para treinarmos); odbc conecta a váriás bases de dados comerciais (SQL Server, por exemplo) utilizando o open conectivity protocol; biquery conecta ao BigQuery do Google. Essas backends estão implementados como pacotes do R também. Para acessar os dados do IPEA, utilizaremos o backend odbc, uma vez que o servidor é o SQL Server ou MS SQL Server. Maiores detalhes sobre como conectar e exemplos de queries contra essas bases de dados serão passados em aula. Para os exemplos desta apostila, utilizaremos RSQlite, porque teremos que emular uma base de dados tipo SQL. 3.1.2 Conectando a um database Para podermos trabalhar com uma base de dados junto com dplyr, primeiro devemos estabelecer uma conexão com esta base, usando DBI::dbConnect(). Criamos assim um objeto de conexão dentro do R que fará a ligação em nossa sessão no RStudio e o anco de dados. # install.packages(&quot;RSQLite&quot;) library(dplyr) con &lt;- DBI::dbConnect(drv = RSQLite::SQLite(), path = &quot;:memory:&quot;) O argumento drv de DBI::dbConnect() pode variar de database para database, mas o primeiro argumento é sempre o driver do tipo de banco de dados ao qual você irá se conectar. Seria RSQLite::SQLite() para SQLite, RMySQL::MySQL() para MySQL, RPostgreSQL::PostgreSQL() para PostgreSQL, odbc::odbc() para SQL Server e bigrquery::bigquery()* para Google BigQuery. SQLite somente precisa de mais um outro argumento: o caminho para a base de dados. No nosso caso, nós usamos a string especial [:memory:] que fará com que SQLite construa uma base de dados temporária na memória de nosso computador. Contudo, a maioria das databases não “vivem” em um arquivo, mas sim em um servidor. Isso significa que na vida real seu código seria mais parecido com: con &lt;- DBI::dbConnect(RMySQL::MySQL(), host = &quot;database.ipea&quot;, user = &quot;treinamento&quot;, password = rstudioapi::askForPassword(&quot;Database password&quot;) ) DICA: Na vida real, ao criarmos o objeto de conexão com o servidor relacional de verdade, você veria uma aba de conexões no RStudio, com os respectivos schemas e/ou tabelas presentes no servidor. É como se fosse um Global Environment do banco de dados: Aba Connections do RStudio A base de dados temporária que criamos anteriormente não possui qualquer tabela de dados ainda. Começaremos, então, por copiar o tibble tb_ibama, usando a função copy_to(). Embora esta não seja a maneira mais indicada de colocar dados em uma database, é bastante útil e fácil para utilizarmos em demonstrações: Caso você não possua mais o tibble, vamos refrescar sua memória: library(readr) tb_ibama &lt;- read_csv(file=&quot;https://raw.githubusercontent.com/allanvc/book_IADR-T/master/datasets/PA%20GF%202017%20jan-jun_editada.csv&quot;, col_types = cols( X1 = col_double(), TIPO_GF = col_character(), STATUS_GF = col_character(), UF_REMETENTE = col_character(), MUNICÍPIO_REMETENTE = col_character(), TIPO_DESTINO = col_character(), CEPROF_DESTINATÁRIO = col_character(), UF_DESTINATÁRIO = col_character(), MUNICÍPIO_DESTINATÁRIO = col_character(), N_AUTORIZAÇÃO = col_character(), PROCESSO = col_character(), EMISSAO = col_integer(), NOME_CIENTÍFICO = col_character(), PRODUTO = col_character(), VOLUME = col_double(), UNID = col_character(), PRECO_TOTAL = col_double() ) ) # tb_ibama$STATUS_GF[1:50000] &lt;- rep(&quot;NÃO VERIFICADO&quot;, 50000) # # tb_ibama2 &lt;- mutate(tb_ibama, # preco_unidade = PRECO_TOTAL / VOLUME, # preco_unidade_vezes_1000 = preco_unidade * 1000 # ) Feito isso, podemos adicionar o tibble contendo os dados do IBAMA para o nosso Banco de Dados relacional fictício: copy_to(con, tb_ibama, &quot;tb_ibamaDB&quot;, temporary = FALSE, indexes = list( &quot;UF_REMETENTE&quot;, &quot;MUNICÍPIO_REMETENTE&quot;, &quot;UF_DESTINATÁRIO&quot;, &quot;MUNICÍPIO_DESTINATÁRIO&quot; ) ) A função copy_to() possui alguns argumentos adicionais que nos permitem fornecer índices para a tabela. Nós, então, criamos índices que nos permitirão rapidamente processar os dados por UF_REMETENTE, MUNICÍPIO_REMETENTE, uf_DESTINATÁRIO e MUNICÍPIO_DESTINATÁRIO. Criar os índices de escrita é um ponto chave para uma boa performance da base de dados ao enviarmos queries. No entanto, está fora do escopo deste curso. Uma vez que copiamos os dados para o servidor, podemos referenciar (ainda não estamos importando) essa tabela no R usando a função tbl(), que extrai a tabela chamada \"tb_ibamaDB\" do database. tb_ibama_db &lt;- tbl(con, &quot;tb_ibamaDB&quot;) Se imprimirmos a referência recém criada, veremos que ela se parece com um tibble, embora seja retratada como uma ista no Global Environment. tb_ibama_db ## # Source: table&lt;tb_ibamaDB&gt; [?? x 17] ## # Database: sqlite 3.39.1 [] ## X1 TIPO_GF STATUS_GF UF_REMETENTE MUNICÍPIO_REMETENTE TIPO_DESTINO CEPROF_DESTINATÁRIO UF_DESTINATÁRIO ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 40644 GF1 RECEBIDO PA Santarém EMPREENDIMENTO… XXXX PA ## 2 153879 GF1 RECEBIDO PA Alenquer EMPREENDIMENTO… XXXX PA ## 3 66847 GF1 RECEBIDO PA Rurópolis EMPREENDIMENTO… XXXX PA ## 4 319645 GF3I RECEBIDO PA Tucuruí EMPREENDIMENTO… &lt;NA&gt; BA ## 5 19190 GF3 RECEBIDO PA Paragominas EMPREENDIMENTO… XXXX PA ## 6 317951 GF2 RECEBIDO PA Breu Branco EMPREENDIMENTO… XXXX PA ## 7 201275 GF3I RECEBIDO PA Benevides EMPREENDIMENTO… &lt;NA&gt; BA ## 8 275969 GF3I RECEBIDO PA Tucuruí EMPREENDIMENTO… &lt;NA&gt; BA ## 9 158094 GF3I RECEBIDO PA Moju EMPREENDIMENTO… &lt;NA&gt; SE ## 10 181537 GF1 RECEBIDO PA Santarém EMPREENDIMENTO… XXXX PA ## # ℹ more rows ## # ℹ 9 more variables: MUNICÍPIO_DESTINATÁRIO &lt;chr&gt;, N_AUTORIZAÇÃO &lt;chr&gt;, PROCESSO &lt;chr&gt;, EMISSAO &lt;int&gt;, ## # NOME_CIENTÍFICO &lt;chr&gt;, PRODUTO &lt;chr&gt;, VOLUME &lt;dbl&gt;, UNID &lt;chr&gt;, PRECO_TOTAL &lt;dbl&gt; A única diferença é a referência de que os dados estão em um banco de dados SQLite. 3.1.3 Gerando queries Para interagir com um banco de dados nós geralmente usamos SQL - Structured Query Language. SQL tem mais de 40 anos e é usado em praticamente todas as bases de dados que existem. O objetivo de dbplyr é automaticamente gerar códigos em SQL para que nós não sejamos forçados a utilizá-los. No entanto, dbplyr não faz tudo que uma linguagem SQL faz. Ele foca na declarativa SELECT e derivados, o que consideramos suficiente para o escopo desse curso. Veja como, na maioria das vezes, não precisamos saber nada de SQL e podemos continuar utilizando os verbos de dplyr com os quais já estamos familiarizados. tb_ibama_db %&gt;% select(TIPO_GF:UF_REMETENTE, UF_DESTINATÁRIO, VOLUME) ## # Source: SQL [?? x 5] ## # Database: sqlite 3.39.1 [] ## TIPO_GF STATUS_GF UF_REMETENTE UF_DESTINATÁRIO VOLUME ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 GF1 RECEBIDO PA PA 2.30 ## 2 GF1 RECEBIDO PA PA 1.26 ## 3 GF1 RECEBIDO PA PA 0.651 ## 4 GF3I RECEBIDO PA BA 2.45 ## 5 GF3 RECEBIDO PA PA 2.31 ## 6 GF2 RECEBIDO PA PA 25.5 ## 7 GF3I RECEBIDO PA BA 3.98 ## 8 GF3I RECEBIDO PA BA 1.70 ## 9 GF3I RECEBIDO PA SE 4.21 ## 10 GF1 RECEBIDO PA PA 2.52 ## # ℹ more rows tb_ibama_db %&gt;% filter(VOLUME &gt; 1) ## # Source: SQL [?? x 17] ## # Database: sqlite 3.39.1 [] ## X1 TIPO_GF STATUS_GF UF_REMETENTE MUNICÍPIO_REMETENTE TIPO_DESTINO CEPROF_DESTINATÁRIO UF_DESTINATÁRIO ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 40644 GF1 RECEBIDO PA Santarém EMPREENDIMENTO… XXXX PA ## 2 153879 GF1 RECEBIDO PA Alenquer EMPREENDIMENTO… XXXX PA ## 3 319645 GF3I RECEBIDO PA Tucuruí EMPREENDIMENTO… &lt;NA&gt; BA ## 4 19190 GF3 RECEBIDO PA Paragominas EMPREENDIMENTO… XXXX PA ## 5 317951 GF2 RECEBIDO PA Breu Branco EMPREENDIMENTO… XXXX PA ## 6 201275 GF3I RECEBIDO PA Benevides EMPREENDIMENTO… &lt;NA&gt; BA ## 7 275969 GF3I RECEBIDO PA Tucuruí EMPREENDIMENTO… &lt;NA&gt; BA ## 8 158094 GF3I RECEBIDO PA Moju EMPREENDIMENTO… &lt;NA&gt; SE ## 9 181537 GF1 RECEBIDO PA Santarém EMPREENDIMENTO… XXXX PA ## 10 187630 GF3 RECEBIDO PA Paragominas EMPREENDIMENTO… XXXX PA ## # ℹ more rows ## # ℹ 9 more variables: MUNICÍPIO_DESTINATÁRIO &lt;chr&gt;, N_AUTORIZAÇÃO &lt;chr&gt;, PROCESSO &lt;chr&gt;, EMISSAO &lt;int&gt;, ## # NOME_CIENTÍFICO &lt;chr&gt;, PRODUTO &lt;chr&gt;, VOLUME &lt;dbl&gt;, UNID &lt;chr&gt;, PRECO_TOTAL &lt;dbl&gt; tb_ibama_db %&gt;% group_by(UF_DESTINATÁRIO) %&gt;% summarise(vol_medio_por_UF = mean(VOLUME)) ## # Source: SQL [?? x 2] ## # Database: sqlite 3.39.1 [] ## UF_DESTINATÁRIO vol_medio_por_UF ## &lt;chr&gt; &lt;dbl&gt; ## 1 AL 3.06 ## 2 AM 894. ## 3 BA 2.94 ## 4 CE 3.99 ## 5 DF 4.93 ## 6 ES 3.48 ## 7 GO 5.13 ## 8 MA 5.27 ## 9 MG 5.35 ## 10 MS 5.42 ## # ℹ more rows No entanto, no longo prazo é altamente recomendado que você aprenda pelo menos o básico de SQL. SQL é uma skill bastante importante para qualquer cientista de dados ou pessoas que lidam com dados rotineiramente. A diferença mais importante entre dataframes comuns e queries a bancos de dados remotos é que nosso código R é traduzido para linguagem SQL e executado na database, não no R. Quando trabalhamos com databases o dplyr tenta ser o mais preguiçoso possível. O dplyr se vale de um conceito bastante utilizado no R, que é o lazy evaluation: Ele nunca traz dados para o R a não ser que explicitamente solicitemos que ele faça isso; Ele “atrasa” fazer qualquer tarefa até o último momento: ele coleta todos comandos e manda para o banco de dados em um único passo. Veja o exemplo a seguir: por_uf_dest_db &lt;- tb_ibama_db %&gt;% group_by(UF_DESTINATÁRIO) %&gt;% summarise( preco_medio = mean(PRECO_TOTAL, na.rm=TRUE), n = n() ) %&gt;% arrange(desc(preco_medio)) %&gt;% filter(n &gt; 100) É suprpreendente o que vamos dizer agora, mas todos esses códigos não chegam a tocar a base de dados em nenhum momento; não até que solicitemos, por exemplo fazendo um printing do objeto criado por_uf_dest_db. Somente, então, é que dplyr gera o código SQL e solicita os resultados da base de dados no servidor SQL. Ainda sim, ele tenta minimizar o que será impresso, trazendo apenas algumas linhas e não tudo. Vea: por_uf_dest_db ## # Source: SQL [?? x 3] ## # Database: sqlite 3.39.1 [] ## # Ordered by: desc(preco_medio) ## UF_DESTINATÁRIO preco_medio n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 PR 14828. 366 ## 2 SC 9661. 280 ## 3 RS 5473. 143 ## 4 SP 3420. 1580 ## 5 MG 3209. 1573 ## 6 GO 2802. 418 ## 7 SE 2666. 854 ## 8 MA 2434. 736 ## 9 RJ 2425. 770 ## 10 TO 2169. 143 ## # ℹ more rows Por de trás dos panos, dbplyr/dplyr está traduzindo o código em R para código SQL. Se você quiser ver (e aprender) o código SQL que está sendo enviado ao servidor, use show_query(): por_uf_dest_db %&gt;% show_query() ## &lt;SQL&gt; ## SELECT `UF_DESTINATÁRIO`, AVG(`PRECO_TOTAL`) AS `preco_medio`, COUNT(*) AS `n` ## FROM `tb_ibamaDB` ## GROUP BY `UF_DESTINATÁRIO` ## HAVING (COUNT(*) &gt; 100.0) ## ORDER BY `preco_medio` DESC Para aqueles que são mais familiazrizados com SQL, o código acima provavelmente não seria o que você escreveria, mas ele cumpre a missão. Veja a vignette(\"SQL-translation\"). Mesmo com dbplyr/dplyr, nós ainda faremos algumas iterações e tentativas até descobrir o que realmente vamos precisar dos dados. No entanto, o faremos de forma muito mais rápida. Uma vez que soubermos exatamente nosso objetivo, podemos usar collect() para trazer todos os dados em um tibble (local) em nossa máquina: por_uf_dest_final &lt;- por_uf_dest_db %&gt;% collect() por_uf_dest_final ## # A tibble: 19 × 3 ## UF_DESTINATÁRIO preco_medio n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 PR 14828. 366 ## 2 SC 9661. 280 ## 3 RS 5473. 143 ## 4 SP 3420. 1580 ## 5 MG 3209. 1573 ## 6 GO 2802. 418 ## 7 SE 2666. 854 ## 8 MA 2434. 736 ## 9 RJ 2425. 770 ## 10 TO 2169. 143 ## 11 PA 2113. 75145 ## 12 RN 2053. 1581 ## 13 ES 2031. 269 ## 14 CE 2002. 3172 ## 15 AL 1499. 2025 ## 16 PB 1458. 2112 ## 17 BA 1386. 4458 ## 18 PE 1266. 2655 ## 19 PI 1197. 1635 collect() precisa que o banco de dados trabalhe e, por isso, a operação pode tomar algum tempo até ser completada. Por outro lado, dbplyr tenta evitar que você acidentalmente faça queries bem custosas computacionalmente: Geralmente não há forma de determinar quantas linhas uma query vai retornar até que realmente a executemos. Diferente de quando estamos trabalhando com base de dados em nosso PC, o comando nrow() sempre retorna NA ao dispararmos contra bancos de dados relacionais; Como não podemos encontrar as poucas últimas linhas sem executar a query de todo os dados, não podemos usar tail(), que imprime as \\(n\\) últimas linhas de um tibble ou dataframe. nrow(por_uf_dest_db) ## [1] NA tail(por_uf_dest_db) ## Error in `tail()`: ## ! `tail()` is not supported on database backends. 3.1.4 Referências da seção Wickham, H.; Ruiz, E. (2019). dbplyr: A ‘dplyr’ Back End for Databases. R package version 1.4.0. URL https://CRAN.R-project.org/package=dbplyr. ____. (2020). dbplyr vignette: Introduction. URL http://dbplyr.tidyverse.org. Ruiz, E. (2017). Databases using R. RViews-RStudio. May 05, 2017. Disponível em: https://rviews.rstudio.com/2017/05/17/databases-using-r/ 3.1.5 Exercícios Utilize os dados de acesso ao servidor do IPEA que serão informados em aula para explorar as bases existentes e aplicar o conhecimento adquirido sobre os pacotes dplyr, dbplyr e ggplot2 3.2 Manipulação de dados com Two-table verbs - dplyr A Análise de dados, na maioria das vezes, envolve mais de uma base de dados. Na prática, são bases de fontes distintas que contribuem para chegarmos a um resultado final. Dessa forma, precisamos de ferramentas flexiveis para combiná-las. No pacote dplyr, existem três famílias de verbos que trabalham com duas tabelas de uma vez: mutating joins, que adicionam novas variáveis a uma tabela a partir da correspondência (matching) das linhas em outra; filtering joins, que filtram observações de uma tabela se estas observações fazem o matching com uma observação em outra tabela; set oeprations, que combinam observações nos datasets caso eles sejam elementos do conjunto informado. Esses itens assumem que seus dados encontram-se no formto de tidy data, ou seja, linhas são observações e colunas são variáveis. Todos os two-table verbs (ou funções de duas tabelas) funcionam de forma similar: os primeiros dois argumentos são x e y e fornecem as duas tabelas que desejamos comparar e combinar. O output será sempre uma nova tabela com o mesmo tipo de objeto de x. 3.2.1 Mutating joins Mutating joins nos permitem combinar variáveis de múltiplas tabelas. Vamos utilizar alguns datasets do pacote nycflights13 que contempla os dados de 336.776 voos (tibble flights), as condições climáticas (tibble weather) e as aeronaves (tibble planes) que pousaram e decolaram de 3 aeroportos (tibble airports) de Nova York em 2013. Os dados são oriundos do US Bureau of Transportation Statistics. Inicialmente usaremos o datase flights. Vamos separar algumas colunas do tibble original em outro. Depois tentaremos juntar os dois com base no nome da cia aérea. library(&quot;nycflights13&quot;) # Drop unimportant variables so it&#39;s easier to understand the join results. flights2 &lt;- flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) flights2 %&gt;% left_join(airlines) ## Joining with `by = join_by(carrier)` ## # A tibble: 336,776 × 9 ## year month day hour origin dest tailnum carrier name ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 EWR IAH N14228 UA United Air Lines Inc. ## 2 2013 1 1 5 LGA IAH N24211 UA United Air Lines Inc. ## 3 2013 1 1 5 JFK MIA N619AA AA American Airlines Inc. ## 4 2013 1 1 5 JFK BQN N804JB B6 JetBlue Airways ## 5 2013 1 1 6 LGA ATL N668DN DL Delta Air Lines Inc. ## 6 2013 1 1 5 EWR ORD N39463 UA United Air Lines Inc. ## 7 2013 1 1 6 EWR FLL N516JB B6 JetBlue Airways ## 8 2013 1 1 6 LGA IAD N829AS EV ExpressJet Airlines Inc. ## 9 2013 1 1 6 JFK MCO N593JB B6 JetBlue Airways ## 10 2013 1 1 6 LGA ORD N3ALAA AA American Airlines Inc. ## # ℹ 336,766 more rows 3.2.1.1 Controlando como as tabelas sofrem match nos mutating joins Juntamente com os argumentos x e y, cada mutating join recebe também um argumento by que é utilizado como índice para fazer o matching entre as tabelas. Há algumas maneiras de especificar esse argumento. Vejamos exemplos de como especificar o parâmetro by, utilizando algumas tabelas de nycflights13. 1ª forma) NULL: o default. dplyr vai usar todas as variáveis que aparecerem nas duas tabelas. Chamamos isso de natural join. No exeplo a seguir, as tabelas flights e wheather serão “juntadas” com base nas variáveis comuns: year, month, day, hour e origin. flights2 %&gt;% left_join(weather) ## Joining with `by = join_by(year, month, day, hour, origin)` ## # A tibble: 336,776 × 18 ## year month day hour origin dest tailnum carrier temp dewp humid wind_dir wind_speed wind_gust precip ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 5 EWR IAH N14228 UA 39.0 28.0 64.4 260 12.7 NA 0 ## 2 2013 1 1 5 LGA IAH N24211 UA 39.9 25.0 54.8 250 15.0 21.9 0 ## 3 2013 1 1 5 JFK MIA N619AA AA 39.0 27.0 61.6 260 15.0 NA 0 ## 4 2013 1 1 5 JFK BQN N804JB B6 39.0 27.0 61.6 260 15.0 NA 0 ## 5 2013 1 1 6 LGA ATL N668DN DL 39.9 25.0 54.8 260 16.1 23.0 0 ## 6 2013 1 1 5 EWR ORD N39463 UA 39.0 28.0 64.4 260 12.7 NA 0 ## 7 2013 1 1 6 EWR FLL N516JB B6 37.9 28.0 67.2 240 11.5 NA 0 ## 8 2013 1 1 6 LGA IAD N829AS EV 39.9 25.0 54.8 260 16.1 23.0 0 ## 9 2013 1 1 6 JFK MCO N593JB B6 37.9 27.0 64.3 260 13.8 NA 0 ## 10 2013 1 1 6 LGA ORD N3ALAA AA 39.9 25.0 54.8 260 16.1 23.0 0 ## # ℹ 336,766 more rows ## # ℹ 3 more variables: pressure &lt;dbl&gt;, visib &lt;dbl&gt;, time_hour &lt;dttm&gt; 2ª forma) by = \"var1\" ou by = c(\"var1\", \"var2\", \"var3\"): um vetor de caracteres. Opera como se fosse um natural join, mas utiliza somente algumas das variáveis comuns. Por exemplo, flights e planes possuem uma variável year, mas elas significam coisas diferentes em cada tibbe/dataframe. Então, queremos especificar uma coluna que sabemos que significa a mesma coisa em ambos os tibbles e que possa servir de índice para o matching. Vamos usar tailnum que é o número (de cauda) do avião. flights2 %&gt;% left_join(planes, by = &quot;tailnum&quot;) ## # A tibble: 336,776 × 16 ## year.x month day hour origin dest tailnum carrier year.y type manufacturer model engines seats speed ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 5 EWR IAH N14228 UA 1999 Fixed wi… BOEING 737-… 2 149 NA ## 2 2013 1 1 5 LGA IAH N24211 UA 1998 Fixed wi… BOEING 737-… 2 149 NA ## 3 2013 1 1 5 JFK MIA N619AA AA 1990 Fixed wi… BOEING 757-… 2 178 NA ## 4 2013 1 1 5 JFK BQN N804JB B6 2012 Fixed wi… AIRBUS A320… 2 200 NA ## 5 2013 1 1 6 LGA ATL N668DN DL 1991 Fixed wi… BOEING 757-… 2 178 NA ## 6 2013 1 1 5 EWR ORD N39463 UA 2012 Fixed wi… BOEING 737-… 2 191 NA ## 7 2013 1 1 6 EWR FLL N516JB B6 2000 Fixed wi… AIRBUS INDU… A320… 2 200 NA ## 8 2013 1 1 6 LGA IAD N829AS EV 1998 Fixed wi… CANADAIR CL-6… 2 55 NA ## 9 2013 1 1 6 JFK MCO N593JB B6 2004 Fixed wi… AIRBUS A320… 2 200 NA ## 10 2013 1 1 6 LGA ORD N3ALAA AA NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA NA NA ## # ℹ 336,766 more rows ## # ℹ 1 more variable: engine &lt;chr&gt; Note que ao juntar todas as colunas de ambos os tibbles, dplyr acrescenta um sufixo à segunda variável year. 3ª forma) by = c(\"var1\" = \"var3\"): um vetor de caracteres com nomes: . Isto vai fazer o matching da variável var1 na tabela x com a variável var3 na tabela y. As variáveis da tabela de origem x serão usadas no output. Cada voo tem uma origem e um aeroporto de destino. Então precisamos especificar em qual dessas variáveis do dataset flight queremos fazer o matching com a coluna faa do dataset airports. flights2 %&gt;% left_join(airports, c(&quot;dest&quot; = &quot;faa&quot;)) ## # A tibble: 336,776 × 15 ## year month day hour origin dest tailnum carrier name lat lon alt tz dst tzone ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 EWR IAH N14228 UA George Bush Interco… 30.0 -95.3 97 -6 A Amer… ## 2 2013 1 1 5 LGA IAH N24211 UA George Bush Interco… 30.0 -95.3 97 -6 A Amer… ## 3 2013 1 1 5 JFK MIA N619AA AA Miami Intl 25.8 -80.3 8 -5 A Amer… ## 4 2013 1 1 5 JFK BQN N804JB B6 &lt;NA&gt; NA NA NA NA &lt;NA&gt; &lt;NA&gt; ## 5 2013 1 1 6 LGA ATL N668DN DL Hartsfield Jackson … 33.6 -84.4 1026 -5 A Amer… ## 6 2013 1 1 5 EWR ORD N39463 UA Chicago Ohare Intl 42.0 -87.9 668 -6 A Amer… ## 7 2013 1 1 6 EWR FLL N516JB B6 Fort Lauderdale Hol… 26.1 -80.2 9 -5 A Amer… ## 8 2013 1 1 6 LGA IAD N829AS EV Washington Dulles I… 38.9 -77.5 313 -5 A Amer… ## 9 2013 1 1 6 JFK MCO N593JB B6 Orlando Intl 28.4 -81.3 96 -5 A Amer… ## 10 2013 1 1 6 LGA ORD N3ALAA AA Chicago Ohare Intl 42.0 -87.9 668 -6 A Amer… ## # ℹ 336,766 more rows flights2 %&gt;% left_join(airports, c(&quot;origin&quot; = &quot;faa&quot;)) ## # A tibble: 336,776 × 15 ## year month day hour origin dest tailnum carrier name lat lon alt tz dst tzone ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 EWR IAH N14228 UA Newark Liberty Intl 40.7 -74.2 18 -5 A Ameri… ## 2 2013 1 1 5 LGA IAH N24211 UA La Guardia 40.8 -73.9 22 -5 A Ameri… ## 3 2013 1 1 5 JFK MIA N619AA AA John F Kennedy Intl 40.6 -73.8 13 -5 A Ameri… ## 4 2013 1 1 5 JFK BQN N804JB B6 John F Kennedy Intl 40.6 -73.8 13 -5 A Ameri… ## 5 2013 1 1 6 LGA ATL N668DN DL La Guardia 40.8 -73.9 22 -5 A Ameri… ## 6 2013 1 1 5 EWR ORD N39463 UA Newark Liberty Intl 40.7 -74.2 18 -5 A Ameri… ## 7 2013 1 1 6 EWR FLL N516JB B6 Newark Liberty Intl 40.7 -74.2 18 -5 A Ameri… ## 8 2013 1 1 6 LGA IAD N829AS EV La Guardia 40.8 -73.9 22 -5 A Ameri… ## 9 2013 1 1 6 JFK MCO N593JB B6 John F Kennedy Intl 40.6 -73.8 13 -5 A Ameri… ## 10 2013 1 1 6 LGA ORD N3ALAA AA La Guardia 40.8 -73.9 22 -5 A Ameri… ## # ℹ 336,766 more rows 3.2.1.2 Tipos de mutating joins Há 4 tipos de mutating join, que diferem pelo comportamento nas linhas em que não ocorre o matching entre as bases. Vamos criar dois dataframes e depois veremos exemplos de cada caso. library(dplyr) (df1 &lt;- data_frame(x = c(1, 2), y = 2:1)) ## Warning: `data_frame()` was deprecated in tibble 1.1.0. ## ℹ Please use `tibble()` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. ## # A tibble: 2 × 2 ## x y ## &lt;dbl&gt; &lt;int&gt; ## 1 1 2 ## 2 2 1 # note que a função dplyr::data_frame é diferente da função data.frame do R base (df2 &lt;- data_frame(x = c(1, 3), a = 10, b = &quot;a&quot;)) ## # A tibble: 2 × 3 ## x a b ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 10 a ## 2 3 10 a inner_join(x, y): inclui somente observações que possuem correspondência tanto em x quanto em y (ou seja, linhas iguais nos dataframes). df1 %&gt;% inner_join(df2) ## Joining with `by = join_by(x)` ## # A tibble: 1 × 4 ## x y a b ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 2 10 a Note que o argumento by foi suprido. Dessa forma, o comportamento da funçõ foi o default. A coluna x foi utilizada como índice para juntar os dois data frames. As linhas iguais para a variável x em ambos os datafrmaes são trazidas na íntegra (ou seja, apresentam-se todas as colunas). left_join(x, y): inclui todas as observações em x, independente haver matching ou não entre as tabelas. Esse é o tipo de join mais usado, porque ele garante que nós não perderemos nenhuma informação da nossa tabela primária x. df1 %&gt;% left_join(df2) ## Joining with `by = join_by(x)` ## # A tibble: 2 × 4 ## x y a b ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 2 10 a ## 2 2 1 NA &lt;NA&gt; right_join(x, y): inclui todas as observações da tabela y. É equivalente a left_join(**y**, **x**), mas a ordenação das variáveis será diferente nesse último caso: df1 %&gt;% right_join(df2) ## Joining with `by = join_by(x)` ## # A tibble: 2 × 4 ## x y a b ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 2 10 a ## 2 3 NA 10 a df2 %&gt;% left_join(df1) ## Joining with `by = join_by(x)` ## # A tibble: 2 × 4 ## x a b y ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 10 a 2 ## 2 3 10 a NA full_join(): inclui todas as observações da tabela x e da y: df1 %&gt;% full_join(df2) ## Joining with `by = join_by(x)` ## # A tibble: 3 × 4 ## x y a b ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 2 10 a ## 2 2 1 NA &lt;NA&gt; ## 3 3 NA 10 a Os left, right e full joins são conhecidos coletivamente como outer joins (ou joins externos). Quando a linha de uma tabela não possui correspondência nenhuma na outra tabel, em um outer join, as novas variáveis são preenchidas com missing values (NA). Embora os mutating joins existam para adicionar novas variáveis, em alguns casos eles podem gerar novas observações. Se uma correspondência não é única, um join vai acrescentar linhas para todas as combinações possíveis (produto cartesiano) do matching das observações. Esta é uma observação importante, pois muitas vezes, ao realiza um join entre duas tabelas, não compreendemos o porquê de a tabela resultante do join possuir mais observações que as duas tabelas originais. df1 &lt;- data_frame(x = c(1, 1, 2), y = 1:3) df2 &lt;- data_frame(x = c(1, 1, 2), z = c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;)) df1 %&gt;% left_join(df2) ## Joining with `by = join_by(x)` ## Warning in left_join(., df2): Detected an unexpected many-to-many relationship between `x` and `y`. ## ℹ Row 1 of `x` matches multiple rows in `y`. ## ℹ Row 1 of `y` matches multiple rows in `x`. ## ℹ If a many-to-many relationship is expected, set `relationship = &quot;many-to-many&quot;` to silence this warning. ## # A tibble: 5 × 3 ## x y z ## &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; ## 1 1 1 a ## 2 1 1 b ## 3 1 2 a ## 4 1 2 b ## 5 2 3 a 3.2.2 Filtering joins Filtering joins “casam” observações da mesma forma que os mutating joins, mas afetam as próprias observações e não as variáveis. Existem dois tipos de filtering joins: semi_join() MANTÉM todas as observações em x que possuem correspondência em y; anti_join() RETIRA todas as observações em x que possuem correspondência em y. Esses joins são muito úteis para identificar “descasamentos” entre tabelas. Por exemplos, há diversos voos no dataset flights que não possuem correspondências com relação ao tailnum no dataset planes: flights %&gt;% anti_join(planes, by = &quot;tailnum&quot;) %&gt;% count(tailnum, sort = TRUE) ## # A tibble: 722 × 2 ## tailnum n ## &lt;chr&gt; &lt;int&gt; ## 1 &lt;NA&gt; 2512 ## 2 N725MQ 575 ## 3 N722MQ 513 ## 4 N723MQ 507 ## 5 N713MQ 483 ## 6 N735MQ 396 ## 7 N0EGMQ 371 ## 8 N534MQ 364 ## 9 N542MQ 363 ## 10 N531MQ 349 ## # ℹ 712 more rows Caso você esteja preocupado com quais observações nosso join vai fazer o matching, sugere-se iniciar com um semi_join() ou anti_join() pelo seguinte motivo: esses joins nunca duplicam as observações, eles somente removem ou as mantém no mesmo número. df1 &lt;- data_frame(x = c(1, 1, 3, 4), y = 1:4) df2 &lt;- data_frame(x = c(1, 1, 2), z = c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;)) # Four rows to start with: df1 %&gt;% nrow() ## [1] 4 # And we get four rows after the join df1 %&gt;% inner_join(df2, by = &quot;x&quot;) %&gt;% nrow() ## Warning in inner_join(., df2, by = &quot;x&quot;): Detected an unexpected many-to-many relationship between `x` and `y`. ## ℹ Row 1 of `x` matches multiple rows in `y`. ## ℹ Row 1 of `y` matches multiple rows in `x`. ## ℹ If a many-to-many relationship is expected, set `relationship = &quot;many-to-many&quot;` to silence this warning. ## [1] 4 # But only two rows actually match df1 %&gt;% semi_join(df2, by = &quot;x&quot;) %&gt;% nrow() ## [1] 2 Por fim, cabe fazer menção a funções que seriam úteis caso você tivesse que trabalhar com 3 ou mais tabelas. Dê uma lida em purrr::reduce() ou Reduce(), como descrito em “Advanced R”, para iterativamente combinar espandir seus conhecimentos de two-table verbs de modo a lidar com um número maior de tabelas. O conteúdo deste capítulo foi adaptado da vignette de two-table verbs, disponível em http://dplyr.tidyverse.org/articles/two-table.html. 3.2.3 Referências da seção Wickham H.; François, R.; Henry, L.; Müller K. (2019). dplyr: A Grammar of Data Manipulation. R package version 0.8.1. URL https://CRAN.R-project.org/package=dplyr. Wickham H.; François, R.; Henry, L.; Müller K. (2020). dplyr vignette: Two-table. Article._ Disponível em: http://dplyr.tidyverse.org/articles/two-table.html. Wickham, H.; Grolemund, G. (2016). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. O’Reilly Media. december 2016. 522 pages. Disponível em: htps://www.r4ds.co.nz. 3.2.4 Exercícios Procure replicar cada um dos joins apresentados nesta seção às tabelas [dbo].[licitacoes] nos schemas ComprasPI e ComprasCE do servidor relacional do IPEA. 3.3 Análise de dados geográficos no R 3.3.1 Introdução Nas últimas décadas houve uma verdadeira revolução das técnicas de geocomputação. Graças a esse grande avanço, a análise de dados geográficos não se restringe mais apenas àqueles que tem acesso a hardwares e softwares caros. De certa forma, podemos dizer que o R também contribuiu para este avanço. Embora a linguagem possuísse algumas limitações referentes à geocomputação nos anos iniciais de desenvolvimento da linguagem, ultimamente diversos pacotes do R levaram a geocomputação a um novo patamar, principalmente no que diz respeito à reproducibilidade. Enquanto os softwares baseados em Sistemas de Informações Geográficas (SIG ou GIS no inglês), que tem como disciplina base a Geografia e o foco voltado para interfaces gráficas, deixam a desejar na reproducibilidade dos mapas gerados, o R, que tem como base a Estatística e Computação por meio de linha de comando e programação, faz com que a análise geográfica de dados seja muito mais fluida e passível de reprodução por outros usuários e desenvolvedores. Nesta seção, apresentaremos alguns dos principais pacotes e técnicas utilizadas para produção de mapas usando R. 3.3.1.1 Modelos de dados geográficos: vetor vs raster No campo da geocomputação, precisamos saber diferenciar os dois tipos de dados geográficos principais: vetor e raster. Dados geográficos em forma de vetor utilizam pontos, linhas e polígonos para representar um mapa. Nesse caso, as bordas dos objetos (ex: Estados, Municípios, Países) são bem definidos. Figure 3.1: Exemplo de plot em vetor Já os dados em formato raster dividem a superfície de um mapa em células de tamanhos constantes. Os datasets em formato raster são comumente utilizados para gerar mapas como imagens de fundo (background). Os modelos raster são utilizados praticamente desde a origem dos aparelhos e satélites de Sensoriamento Remoto. Figure 3.2: Plot em raster: Batimetria do Golfo do México (https://geo.gcoos.org/data/topography/SRTM30PLUS.html) Neste curso, focaremos nos modelos de dados geográficos em vetor, que é o modelo de dados predominante nas Ciências Sociais. Isso, porque os arranjos espaciais produzidos pelo homem tendem a possuir limites discretos e bem definidos. Já o modelo raster é mais utilizado em ciências ambientais ou da terra devido à utilização de dados oriundos de sensoriamento remoto. Agora que sabemos as diferenças conceituais entre os principais modelos de dados geográficos, vamos à prática. 3.3.2 Produção de Mapas no R 3.3.2.1 Shapefiles Shapefiles são arquivos que seguem o modelo de dados geográficos em vetor, contendo elementos gráficos em formato de ponto, linha e/ou polígonos podendo ser trabalhados juntamente com coordenadas geográficas para descrever um fenômeno específico, como tamanho de população, incidência de doenças, etc. A partir dessas informações, é possível, então, construir-se um mapa. Um shapefile, normalmente, contém três arquivos principais .shp, .shx, .dbf. Existem diversos locais de onde você pode obter shapefiles para confecção de mapas. Se o seu objetivo é obter shapefiles para a malha territorial brasileira, você pode obtê-las nessas três fontes: IBGE: ftp://geoftp.ibge.gov.br/organizacao_do_territorio/malhas_territoriais/malhas_municipais/municipio_2017/ IPEAGEO: http://www.ipea.gov.br/ipeageo/malhas.html GADM: https://gadm.org/download_country_v3.html No caso da GADM, o repositório possui tanto as shapefiles quanto arquivos em R para importação da malha terriorial de diversos países e suas subdivisões administrativas. É um repositório bastante completo e mais fácil de navegar do que o do IBGE e do IPEA. DICA: O IPEA recentemente desenvolveu o pacote geobr, que facilita a obtenção das shapefiles diretamente pelo R. Focaremos na demonstração de como obter shapefiles a partir do repositório do IBGE. Para qualquer outra fonte de dados, os procedimentos serão praticamente os mesmos. 3.3.2.2 Mapa da malha estadual brasileira 3.3.2.2.1 Obtenção do arquivo Você pode obtar por realizar o download do arquivo br_unidade_da_federacao.zip, que contém as shapefiles para os estados brasileiros, diretamente do ftp do IBGE, como na imagem abaixo: FTP Server do IBGE No entanto, sugerimos utilizar a solução abaixo que faz tudo issoa partir do R, utilizando as funções download.file() e unzip(). # obtém arquivo zip download.file(&quot;ftp://geoftp.ibge.gov.br/organizacao_do_territorio/malhas_territoriais/malhas_municipais/municipio_2018/Brasil/BR/br_unidades_da_federacao.zip&quot;, destfile = &#39;shp_ibge_uf2018.zip&#39;) # escolhe um nome para o arquivo zip na máquina # descompactar arquivo unzip(zipfile = &quot;shp_ibge_uf2018.zip&quot;, exdir = &#39;shp_ibge_uf2018&#39;) # nome da pasta a ser criada para receber os arquivos do zip 3.3.2.2.2 Leitura do arquivo .shp Agora podemos ler o shapefile utilizando o pacote sf, que quer dizer simple features. Este é um termo bastante utilizado na geocomputação, pois serve para descrever como objetos do mundo real são representados no computador, principalmente objetos de cunho geográfico. O pacote sf, portanto, serve como interface para que isto possa ser feito no R. Além disso, o pacote sf facilita a integração com pacotes do tidyverse. A princípio, a função que você mais vai utilizar do pacote sf é a st_read(), que serve justamente para ler shapefiles de modo que sejam representadas como um por um objeto de classe data.frame no R. Como na leitura de todo dataframe, a função st_read() também precisa que setemos stringsAsFactors=FALSE, para que as variáveis categóricas não sejam lidas como fatores. # lendo arquivo .shp shp_uf = st_read(&quot;./shp_ibge_uf2018/BRUFE250GC_SIR.shp&quot;, stringsAsFactors=FALSE) ## Reading layer `BRUFE250GC_SIR&#39; from data source ## `/home/allan/Documents/teaching/book_IADR-T/shp_ibge_uf2018/BRUFE250GC_SIR.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 27 features and 3 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -73.99045 ymin: -33.75118 xmax: -28.84764 ymax: 5.271841 ## Geodetic CRS: SIRGAS 2000 Vejamos o conteúdo deste arquivo: shp_uf ## Simple feature collection with 27 features and 3 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -73.99045 ymin: -33.75118 xmax: -28.84764 ymax: 5.271841 ## Geodetic CRS: SIRGAS 2000 ## First 10 features: ## NM_ESTADO NM_REGIAO CD_GEOCUF geometry ## 1 SERGIPE NORDESTE 28 MULTIPOLYGON (((-37.98248 -... ## 2 MARANHÃO NORDESTE 21 MULTIPOLYGON (((-44.48155 -... ## 3 ESPÍRITO SANTO SUDESTE 32 MULTIPOLYGON (((-29.33711 -... ## 4 AMAZONAS NORTE 13 MULTIPOLYGON (((-69.61341 -... ## 5 RORAIMA NORTE 14 MULTIPOLYGON (((-63.97805 2... ## 6 GOIÁS CENTRO-OESTE 52 MULTIPOLYGON (((-49.36953 -... ## 7 AMAPÁ NORTE 16 MULTIPOLYGON (((-53.27918 2... ## 8 RIO GRANDE DO SUL SUL 43 MULTIPOLYGON (((-49.70392 -... ## 9 PARAÍBA NORDESTE 25 MULTIPOLYGON (((-34.79576 -... ## 10 PIAUÍ NORDESTE 22 MULTIPOLYGON (((-42.91539 -... Note que além dos nomes dos Estados, da Região a que pertence e o código de geoidentificação do estado CD_GEOCUF, este dataframe especial possui uma coluna chamada geometry. Esta coluna possui os elementos vetoriais geométricos para confecção do mapa no modelo de dados vetor mencionado anteriormente. 3.3.2.2.3 Plotagem do Mapa Para realizar a plotagem do mapa, precisaremos de outro pacote. Há diversos pacotes para plotagem de mapas no R, mas optaremos pelo pacote tmap, por entendermos ser o mais completo atualmente. Um aspecto interessante de tmap é que ele funciona com a plotagem em camadas, assim como o ggplot2 visto no Módulo 2. Podemos ajustar diversos aspectos como legendas, bordas, fronteiras, cores, etc. Primeiramente devemos especificar o dataframe base criado a partir da leitura da shapefile, utilizando a função tm_shape(nome_data_frame). Feito isso, a plotagem dos polígonos da coluna geometry de shp_uf já pode ser feita ao acrescentarmos a camada de polígonos com tm_borders() ou tm_ploygons(). library(tmap) tmap_options(check.and.fix = TRUE) tm_shape(shp_uf)+ tm_borders() ## Warning: The shape shp_uf is invalid. See sf::st_is_valid # OU # tm_shape(shp_uf)+ # tm_polygons() DICA: Pode ocorrer de alguns shapefiles do IBGE perderem a formatação dentro do R e não serem mais reconhecidos como um datatframe que contem dados espaciais, o que acarretará em um erro ao tentarmos plotar o mapa. Para retomar o tipo adequado do objeto, você pode utilizar a função st_as_sf() do pacote sf, i.e. objeto_espacial &lt;- st_as_sf(objeto_espacial). Muito simples fazer mapas no R, não? 3.3.2.2.4 Adicionando dados ao mapa Normalmente, ao fazermos análises geográficas, nosso objetivo é representar algum fênomeno que ocorre no território, como por exemplo o comportamento da taxa de desemprego por UF. Normalmente esses dados vem de uma outra fonte, ou seja, estão em outra base de dados que precisa ser “juntada” ao nosso dataframe de shapefile. Aqui será muito útil o conhecimento sobre Two table verbs e as funções de join, porque teremos que juntar o dataset que possui os dados do fenômeno que desejamos tratar separado por UF com os dados vetoriais/geométricos de plotagem para cada UF também. Faça a leitura da incidência da taxa de desemprego por UF no Brasil para o ano de 2007 conforme o código abaixo: library(readr) tb_desemp_uf &lt;- read_csv2(file=&quot;https://raw.githubusercontent.com/allanvc/book_IADR-T/master/datasets/tx_desemp_uf2007.csv&quot;) tb_desemp_uf ## # A tibble: 27 × 4 ## UF Nome CO_UNID_GEO Taxa_desemp ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AC Acre 1 5.8 ## 2 AL Alagoas 2 8.4 ## 3 AM Amazonas 1 12.2 ## 4 AP Amapá 1 16.3 ## 5 BA Bahia 2 10.4 ## 6 CE Ceará 2 7.9 ## 7 DF Distrito Federal 5 11.9 ## 8 ES Espírito Santo 3 10.8 ## 9 GO Goiás 5 8.2 ## 10 MA Maranhão 2 8.3 ## # ℹ 17 more rows Agora devemos juntar esses dados ao dataframe contendo os os limites da malha estadual brasileira que trabalhamos anteriormente. Vamos utilizar a função left_join() de dplyr. Vamos fazer a junção das tabelas com base na coluna que contém os nomes dos Estados. Contudo, note que as colunas com os nomes possuem nomes diferentes em cada uma das bases: NM_ESTADO vs Nome. Ainda bem, que já sabemos como tratar este pequeno problema com dplyr. Se estiver em dúvida, volte ao Módulo 2. Antes de você continuar, note também que os nomes dos estados em shp_uf estão em caixa alta, ao passo que em tb_desemp_uf estão apenas com a primeira letra maiúscula. Para contornar este problema, usaremos a função mutate() de dplyr em conjunto com a função toupper() do base R, para transformar todos os nomes da base tb_desemp_uf para caixa alta. library(dplyr) tb_desemp_uf &lt;- tb_desemp_uf %&gt;% mutate(Nome = toupper(Nome)) shape_data_join &lt;- left_join(shp_uf, tb_desemp_uf, by = c(&quot;NM_ESTADO&quot; = &quot;Nome&quot;)) # utilizando aula do two table verbs shape_data_join ## Simple feature collection with 27 features and 6 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -73.99045 ymin: -33.75118 xmax: -28.84764 ymax: 5.271841 ## Geodetic CRS: SIRGAS 2000 ## First 10 features: ## NM_ESTADO NM_REGIAO CD_GEOCUF UF CO_UNID_GEO Taxa_desemp geometry ## 1 SERGIPE NORDESTE 28 SE 2 9.8 MULTIPOLYGON (((-37.98248 -... ## 2 MARANHÃO NORDESTE 21 MA 2 8.3 MULTIPOLYGON (((-44.48155 -... ## 3 ESPÍRITO SANTO SUDESTE 32 ES 3 10.8 MULTIPOLYGON (((-29.33711 -... ## 4 AMAZONAS NORTE 13 AM 1 12.2 MULTIPOLYGON (((-69.61341 -... ## 5 RORAIMA NORTE 14 RR 1 12.1 MULTIPOLYGON (((-63.97805 2... ## 6 GOIÁS CENTRO-OESTE 52 GO 5 8.2 MULTIPOLYGON (((-49.36953 -... ## 7 AMAPÁ NORTE 16 AP 1 16.3 MULTIPOLYGON (((-53.27918 2... ## 8 RIO GRANDE DO SUL SUL 43 RS 4 7.4 MULTIPOLYGON (((-49.70392 -... ## 9 PARAÍBA NORDESTE 25 PB 2 8.5 MULTIPOLYGON (((-34.79576 -... ## 10 PIAUÍ NORDESTE 22 PI 2 4.6 MULTIPOLYGON (((-42.91539 -... Agora temos praticamente tudo pronto para plotar como a taxa de desemprego se distribuia pelos estados no ano de 2007. Para fazer com que essas informações sejam incluídas no mapa, acrescentamos uma layer ao gráfico anterior, utilizando a função tm_fill(\"Taxa_desemp\"). Assim, o polígono de cada estado será preenchido com uma cor diferente dependendo da intensidade da taxa de desemprego verificada naquela UF. Note que nossos dados base agora são shape_data_join. tm_shape(shape_data_join)+ tm_borders()+ tm_fill(&quot;Taxa_desemp&quot;) ## Warning: The shape shape_data_join is invalid. See sf::st_is_valid DICA: Uma vez que acrescentamos uma nova layer com tm_fill(), não poderemos utilizar tm_polygons() para traçar as fronteiras, apenas tm_borders(). 3.3.2.2.5 Melhorias no mapa Podemos melhorar ainda mais nossos mapas, acrescentando outras layers. Podemos controlar a intensidade das fronterias estaduais, o posicionamento da legenda com tm_legend(), o estilo do mapa tm_style(), exibir uma régua de escala tm_scale_bar(), uma rosa dos ventos com tm_compass() e muito mais. Sugerimos ler a documentação do pacote tmap. mapa_desemp2007_uf &lt;- tm_shape(shape_data_join)+ # linhas fronteiras: tm_borders(alpha = 0.1)+ # preenchimento e título legenda: tm_fill(&quot;Taxa_desemp&quot;, title=&quot;Taxa desemprego (%)&quot;)+ # estilo (formatação do gráfico, cores, etc): # tm_style(&quot;classic&quot;)+ # posição da legenda: tm_legend(position=c(&quot;left&quot;, &quot;bottom&quot;))+ # agulha ou rosa dos ventos (posição e tipo): tm_compass(position=c(&quot;right&quot;, &quot;top&quot;), size=3, type=&quot;arrow&quot;)+ # régua de escala: tm_scale_bar()+ # tpitulo fora da área de plotagem: tm_layout(main.title=&quot;Taxa de desemprego por UF, 2007&quot;)+ # créditos/fonte: tm_credits(text=&quot;Fonte: IBGE&quot;) mapa_desemp2007_uf ## Warning: The shape shape_data_join is invalid. See sf::st_is_valid ## Scale bar set for latitude km and will be different at the top and bottom of the map. 3.3.2.2.6 Acrescentando mais dados ao mapa Com tmap, podemos acrescentar mais uma dimensão de dados ao nosso mapa, a partir de outro dataset. Imagine, por exemplo, que desejássemos plotar, além da taxa de desemprego, o % de crescimento do PIB no ano de 2007. Isso, forneceria uma melhor compreensão sobre a situação da economia de cada estado naquele ano. Primeiro vamos ler o dataset cresc_PIB_uf2007.csv, que estão disponíveis no repositório da apostila: tb_cresc_PIB_uf2007 &lt;- read_csv2(file=&quot;https://raw.githubusercontent.com/allanvc/book_IADR-T/master/datasets/cresc_PIB_uf2007.csv&quot;) tb_cresc_PIB_uf2007 ## # A tibble: 27 × 2 ## UF var_PIB2007 ## &lt;chr&gt; &lt;dbl&gt; ## 1  Espírito Santo 7.8 ## 2  Pará 2.2 ## 3  Rondônia 5.2 ## 4  Mato Grosso do Sul 7 ## 5  Mato Grosso 11.3 ## 6  Pernambuco 5.4 ## 7  Piauí 2 ## 8  Sergipe 6.2 ## 9  Ceará 3.3 ## 10  Goiás 5.5 ## # ℹ 17 more rows Vamos realizar o join dessa nova base com o dataset shape_data_join que já conta com os dados de polígono e taxa de desemprego para as unidades da federação. Lembre-se que as colunas referentes aos nomes dos estados em cada base possuem denominações diferentes e que os nomes do dataset do PIB não estão em caixa alta. CUIDADO: Antes que você quebre a cabeça tentando resolver um problema, temos um detalhe na coluna UF do tibble tb_cresc_PIB_uf2007: há um espaço em branco à frente dos nomes dos estados. Resolveremos isso com mutate() + str_trim() do pacote stringr, que remove todos os espaços em branco à frente e depois do nome de uma string. O pacote stringr e a amnipulação de strings serão tratados mais profundamente no Módulo 4. library(stringr) tb_cresc_PIB_uf2007 &lt;- tb_cresc_PIB_uf2007 %&gt;% mutate(UF = toupper(str_trim(UF))) shape_data_join2 &lt;- left_join(shape_data_join, tb_cresc_PIB_uf2007, by = c(&quot;NM_ESTADO&quot; = &quot;UF&quot;)) # utilizando aula do two table verbs shape_data_join2 ## Simple feature collection with 27 features and 7 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -73.99045 ymin: -33.75118 xmax: -28.84764 ymax: 5.271841 ## Geodetic CRS: SIRGAS 2000 ## First 10 features: ## NM_ESTADO NM_REGIAO CD_GEOCUF UF CO_UNID_GEO Taxa_desemp var_PIB2007 ## 1 SERGIPE NORDESTE 28 SE 2 9.8 6.2 ## 2 MARANHÃO NORDESTE 21 MA 2 8.3 9.1 ## 3 ESPÍRITO SANTO SUDESTE 32 ES 3 10.8 7.8 ## 4 AMAZONAS NORTE 13 AM 1 12.2 4.5 ## 5 RORAIMA NORTE 14 RR 1 12.1 2.6 ## 6 GOIÁS CENTRO-OESTE 52 GO 5 8.2 5.5 ## 7 AMAPÁ NORTE 16 AP 1 16.3 5.1 ## 8 RIO GRANDE DO SUL SUL 43 RS 4 7.4 6.5 ## 9 PARAÍBA NORDESTE 25 PB 2 8.5 2.2 ## 10 PIAUÍ NORDESTE 22 PI 2 4.6 2.0 ## geometry ## 1 MULTIPOLYGON (((-37.98248 -... ## 2 MULTIPOLYGON (((-44.48155 -... ## 3 MULTIPOLYGON (((-29.33711 -... ## 4 MULTIPOLYGON (((-69.61341 -... ## 5 MULTIPOLYGON (((-63.97805 2... ## 6 MULTIPOLYGON (((-49.36953 -... ## 7 MULTIPOLYGON (((-53.27918 2... ## 8 MULTIPOLYGON (((-49.70392 -... ## 9 MULTIPOLYGON (((-34.79576 -... ## 10 MULTIPOLYGON (((-42.91539 -... Feitos os devidos ajustes, partimos para a plotagem do mapa. ANtes, porém, precisamos pensar em qual forma geométrica usaremos para apresentação do dado de crescimento do PIB. Considerando, que utilizamos tm_fill() para a variável Taxa_desemp, podemos utilizar círculos cujo tamanho vçao variar conforme a intensidade de crescimento do PIB do estado. Fazemos isso com a função tm_bubbles(), passando o nome da variável para o argumento size. mapa_desempvsPIB2007_uf &lt;- tm_shape(shape_data_join2)+ # linhas fronteiras: tm_borders(alpha = 0.1)+ # preenchimento e título legenda: tm_fill(&quot;Taxa_desemp&quot;, title=&quot;Taxa desemprego (%)&quot;)+ # inserindo a camada que retrata o crescimento do PIB em 2007 tm_bubbles(size=&quot;var_PIB2007&quot;, col = &#39;yellow&#39;, title.size=&#39;Variação PIB (%)&#39;)+ # estilo (formatação do gráfico, cores, etc): # tm_style(&quot;classic&quot;)+ # posição da legenda: tm_legend(position=c(&quot;left&quot;, &quot;bottom&quot;))+ # agulha ou rosa dos ventos (posição e tipo): tm_compass(position=c(&quot;right&quot;, &quot;top&quot;), size=3, type=&quot;arrow&quot;)+ # régua de escala: tm_scale_bar()+ # tpitulo fora da área de plotagem: tm_layout(main.title=&quot;Taxa de desemprego por UF, 2007&quot;)+ # créditos/fonte: tm_credits(text=&quot;Fonte: IBGE&quot;) mapa_desempvsPIB2007_uf ## Warning: The shape shape_data_join2 is invalid. See sf::st_is_valid ## Scale bar set for latitude km and will be different at the top and bottom of the map. 3.3.2.2.7 Outros pacotes para geração de mapas Embora tmap seja um pacote bastante poderoso e flexível para a geração de mapas, há diversas outras alternativas no ecosistema do R para geração tanto de mapas estáticos quanto interativos: maptools, maps, ggmap + ggplot2, cartograph, ggVis, leaflet, dentre outros. 3.3.3 Exportando dados geográficos 3.3.3.1 Escrevendo arquivos de dados vetoriais Assim como na leitura de dados vetoriais, o pacote recomendado para se proceder a escrita de dados é o sf. A função equivalente à st_read() no que se refere à escrita de dados é st_write(). Há vários tipos de arquivos vetoriais que se pode escrever: ESRI Shapefile a mais comum (extensão de arquivo shp), GPX, KML, GeoJSON e GPKG. Normalmente, ao especificar a extensão do arquivo, st_read() já se encarrega de “advinhar” o tipo de arquivo vetorial. Veja um exemplo, com a escrita de uma shapefile .shp: st_write(obj = shape_data_join2, dsn = &quot;uf_join.shp&quot;) Serão produzidos 4 arquivos com extensões .shp, .dbf, .shx e .prj. Caso st_write() não consiga reconhecer o driver adequado, você pode passá-lo como driver=\"ESRI Shapefile\" por exemplo. 3.3.3.2 Escrevendo arquivos de figuras O base R fornece uma série de funções que permitem salvar qualquer tipo de plot, incluindo mapas, nas mais diversas extensões de imagens. As funções são png(), jpeg(), bmp(), tiff(). Para salvar um mapa (e qualquer tipo de plot), você pode seguir a seguinte sequência: abrir um dispositivo de plotagem com qualquer uma das funções anteriores, especificando o nome do arquivo de destino a ser criado filename e as dimensões da figura width e height; executar um plot; fechar o dispositivo de plotagem com dev.off(). png(filename = &quot;mapa_BR_UF.png&quot;, width = 500, height = 350) tm_shape(shp_uf)+ tm_polygons() dev.off() O pacote tmap também possui uma função para salvar os mapas criados a partir do pacote como figuras. Vamos salvar o objeto mapa_desempvsPIB2007_uf, que contém um mapa criado com o pacote tmap. library(tmap) tmap_save(tm = mapa_desempvsPIB2007_uf , filename = &quot;lifeExp_tmap.png&quot;) 3.3.4 Referências da seção Battisti, I.; Smolski, F. (2019). Software R: curso avançado. Disponível em: https://smolski.github.io/livroavancado/ Lovelace, R.; Nowosad, J.; Muenchow, J. (2019). Geocomputation with R. CRS Press. Disponível em: https://geocompr.robinlovelace.net/ Pebesma, E. (2018). Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal 10 (1), 439-446, https://doi.org/10.32614/RJ-2018-009. Tennekes, M. (2018). tmap: Thematic Maps in R. Journal of Statistical Software, 84(6), 1-39. doi:10.18637/jss.v084.i06 (URL:https://doi.org/10.18637/jss.v084.i06). 3.3.5 Exercícios Importe, a partir do R, os datasets tx_part_mulheres_munSP2000.csv e pop_SP.csv disponíveis no repositório git do curso, que contém respectivamente os dados da taxa de participação das mulheres no mercado de trabalho dos municípios paulistas no ano 2000 e a a população de cada município do estado de São Paulo no mesmo. Baixe a malha territorial do Brasil do repositório da GADM (GADM36) https://gadm.org/download_country_v3.html. Faça um mapa do estado de São Paulo, mostrando a distribuição da taxa de participação feminina no mercado de trabalho por município, juntamente com a população por município. "],["m4.html", " 4 Módulo IV 4.1 Manipulação de strings no R com stringr 4.2 Expressões Regulares (REGEX) 4.3 Relatórios e pesquisa reproduzível com rmarkdown", " 4 Módulo IV 4.1 Manipulação de strings no R com stringr 4.1.1 Introdução O pacote stringr, como o próprio nome já diz é um pacote para manipulação de strings e também de expressões regulares. Essas duas técnicas são muito importantes em análise de dados, pois muitas vezes vamos lidar com trechos de textos e colunas de caracteres, onde precisamos encontrar padrões de palavras, números, e-mails, telefones, nomes, etc. Todo o conteúdo referente ao pacote stringr estará baseado na página de introdução ao pacote, disponível em http://stringr.tidyverse.org. Será como uma tradução selecionada e mais amigável do conteúdo disponibilizado pelos autores. Se você desejar se aprofundar mais sobre o assunto, pode recorrer ao livro R for Data Science de Hadley Wickham. Existem quatro famílias principais de funções no pacote stringr: manipulação de caracteres: essas funções nos permite manipular caarcteres individuais dentro de strings e dentro de vetores; ferramentas para lidar com espaços em branco, com as quais poderemos adicionar, remover e manipular espaços em branco; operações sensíveis ao local do usuário (locale sensitive) - essas operações variam dependendo do local considerando o alfabeto utilizado em cada país; funções de pattern matching - essas funções reconhecem 4 “motores” de descrição de padrões. A mais comum são expressões regulares, a qual usaremos neste curso. 4.1.2 Operações com caracteres individuais 4.1.2.1 Obtendo e modificando caracteres # carregamento library(stringr) Para obter o tamanho de uma string use string_length(): str_length(&quot;abc&quot;) ## [1] 3 Para acessar caracteres individuais (posições) ou partes de uma string, podemos usar sub_str(). Esta função recebe como argumentos um vetor de caracteres, uma posição de início e uma posição final. Ambas as posições podem receber um número inteiro positivo ou um inteiro negativo. No caso de a posição passada ser um inteiro positivo, a contagem de posições é feita da esquerda para a direita (do início da string) até se atingir a posição desejada. Quando a posição passada como argumento é um inteiro negativo, a contagem é feita da direita para esquerda (do final da string) até se atingir a posição. Em ambos os casos a forma de avaliação da posição é inclusiva, ou seja, inclui o número que foi passado. Caso as posições passadas ultrapassem os limites da string, o resultado é truncado sem retornar qualquer warning. x &lt;- c(&quot;abcdef&quot;, &quot;ghifjk&quot;) # extraindo 3ª letra str_sub(x, 3, 3) ## [1] &quot;c&quot; &quot;i&quot; # do segundo ao penúltimo caractere str_sub(x, 2, -2) ## [1] &quot;bcde&quot; &quot;hifj&quot; str_sub() também pode ser usada para modificar strings: str_sub(x, 3, 3) &lt;- &quot;X&quot; x ## [1] &quot;abXdef&quot; &quot;ghXfjk&quot; Para duplicar strings individuais, use str_dup(): str_dup(x, c(2, 3)) ## [1] &quot;abXdefabXdef&quot; &quot;ghXfjkghXfjkghXfjk&quot; 4.1.2.2 Espaços em branco As funções a seguir adicionam, removem ou modificanm espaços em branco existentes nas strings. str_pad() preenche uma string com espaços em branco até uma largura fixa. Os espaços em branco podem ser adicionados à esquerda, direita ou em ambos os lados. Esse tipo de função é bastante útil para gerar arquivos do tipo .fwf, ou seja com larguras/tamanhos fixos para as colunas. x &lt;- c(&quot;abc&quot;, &quot;defghi&quot;) str_pad(x, 10) ## [1] &quot; abc&quot; &quot; defghi&quot; str_pad(x, 10, &quot;right&quot;) ## [1] &quot;abc &quot; &quot;defghi &quot; str_pad(x, 10, &quot;both&quot;) ## [1] &quot; abc &quot; &quot; defghi &quot; Podemos ainda preencher a string com outros elementos ao invés de espaços em branco: str_pad(x, 10, &quot;both&quot;, pad=&quot;@&quot;) ## [1] &quot;@@@abc@@@@&quot; &quot;@@defghi@@&quot; str_pad() nunca encurtará uma string: str_pad(x, 4) ## [1] &quot; abc&quot; &quot;defghi&quot; Observação: Se você quiser assegurar que as strings possuem o mesmo tamanho, combine str_pad() com str_trunc(): x &lt;- c(&quot;Curto&quot;, &quot;Esta é uma string longa&quot;) str_trunc(x, 10) ## [1] &quot;Curto&quot; &quot;Esta é ...&quot; str_pad(x, 10) ## [1] &quot; Curto&quot; &quot;Esta é uma string longa&quot; # x %&gt;% # str_trunc(10) %&gt;% # str_pad(10, &quot;right&quot;) O oposto de str_pad() é str_trim(), que remove os leading e trailing spaces: x &lt;- c(&quot; a &quot;, &quot;b &quot;, &quot; c&quot;) str_trim(x) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; str_trim(x, &quot;left&quot;) ## [1] &quot;a &quot; &quot;b &quot; &quot;c&quot; Podemos usar str_wrap() para modificar espaços em branco já existentes de forma a “envelopar” por exemplo um parágrafo de texto para que o comprimento de cada linha seja o mais similar possível. É como se justificássemos o parágrafo. blah_blah_blah &lt;- str_c( &quot;`Rosas são vermelhas, &quot;, &quot;Violetas são azuis, &quot;, &quot;... Em qualquer combinação de palvras &quot;, &quot; str_wrap te dá uma luz &quot; ) # uma alternativa a c() para strings cat(str_wrap(blah_blah_blah, width = 40)) ## `Rosas são vermelhas, Violetas são ## azuis, ... Em qualquer combinação de ## palvras str_wrap te dá uma luz # cat0 é uma alternativa a print 4.1.2.3 Locale sensitive Uma boa parte das funções do pacote stringr são locale sensitive: elas vão se comportar de diferente dependendo do país/região em que o usuário se encontra. Veja exemplos de funções que transformam letras de caixa baixa para caixa alta e vice-versa: x &lt;- &quot;I like horses.&quot; str_to_upper(x) ## [1] &quot;I LIKE HORSES.&quot; str_to_title(x) ## [1] &quot;I Like Horses.&quot; str_to_lower(x) ## [1] &quot;i like horses.&quot; # Veja o caso do idioma turco em que há dois tipos de i: um com &quot;ponto&quot; e outro sem str_to_lower(x, &quot;tr&quot;) ## [1] &quot;ı like horses.&quot; Ordenando strings e seus índices: x &lt;- c(&quot;y&quot;, &quot;i&quot;, &quot;k&quot;) str_order(x) # índices ## [1] 2 3 1 str_sort(x) ## [1] &quot;i&quot; &quot;k&quot; &quot;y&quot; # No idioma da Lituânia, y está entre as letras i and k str_sort(x, locale = &quot;lt&quot;) ## [1] &quot;i&quot; &quot;y&quot; &quot;k&quot; Um aspecto importante é que a configuração default de stringr sempre vem com o idioma em inglês para garantir um comportamento idêntico em qualquer sistema ao se utilizar as funções genéricas. Isso é diferente do que normalmente ocorre com base R, onde a opção global locale normalmente varia com a versão regional do sistema operacional e gera bastante confusão quando vamos desenvolver programas. Para obtermos uma lista das abreviações e regiões disponíveis, é só executarmos stringi::stri_locale_list(). 4.1.3 Pattern matching A vasta maioria das funções de stringr funciona com padrões. Estas funções são parametrizadas pelo tipo de tarefa que elas executam e para quais padrões elas fazem o matching ou pareamento. 4.1.3.1 Tasks Cada função de matching possui os mesmos dois primeiros argumentos: um vetor de strings para processar e um padrão para fazer o pareamento. O pacote stringr disponibiliza algumas funções para: detectar str_detect(); localizar str_locate(); extrair str_extract(); parear str_match(), substituir str_replace(); e separar strings str_split(). Veja um exemplo com algumas strings e uma Expressão Regular para encontrar números de telefone (dos EUA): strings &lt;- c( &quot;apple&quot;, &quot;61 2022 5369&quot;, &quot;61-2020-8753&quot;, &quot;Trabalho: 61-2022-5835; Home: 19.3237.5344&quot; ) phone &lt;- &quot;([1-9]{2})[- .]([0-9][0-9]{3})[- .]([0-9]{4})&quot; str_detect() detecta a presença ou ausência de um padrão e retorna um vetor lógico. str_subset() retorna os elementos de um vetor de caracteres que fazem a correspondência (matching) com uma expressão regular. Para sabermos as posições das _strings_contém números, podemos fazer: # Quais strings contém números str_detect(strings, phone) ## [1] FALSE TRUE TRUE TRUE str_subset(strings, phone) ## [1] &quot;61 2022 5369&quot; &quot;61-2020-8753&quot; ## [3] &quot;Trabalho: 61-2022-5835; Home: 19.3237.5344&quot; str_count() conta o número de correspondências. Para saber quantos números de telefone há em cada string, podemos fazer: str_count(strings, phone) ## [1] 0 1 1 2 str_locate() localiza a primeira posição do padrão procurado de cada string (elemento) presente no vetor e retorna uma matriz numérica com colunas indicando as posições de começo e fim. str_loacte_all() localiza todas as correspondências, retornando uma lista de matrizes numéricas. Em qual posição de cada string, os números de telefone estão localizados? (loc &lt;- str_locate(strings, phone)) ## start end ## [1,] NA NA ## [2,] 1 12 ## [3,] 1 12 ## [4,] 11 22 str_locate_all(strings, phone) ## [[1]] ## start end ## ## [[2]] ## start end ## [1,] 1 12 ## ## [[3]] ## start end ## [1,] 1 12 ## ## [[4]] ## start end ## [1,] 11 22 ## [2,] 31 42 str_extract() extrai o texto correspondente à primeira correspondência dentro da string, retornando um vetor de caracteres. str_extract_all() extrai todos os matches e retorna uma lista de vetores de caracteres. str_extract(strings, phone) ## [1] NA &quot;61 2022 5369&quot; &quot;61-2020-8753&quot; &quot;61-2022-5835&quot; str_extract_all(strings, phone) ## [[1]] ## character(0) ## ## [[2]] ## [1] &quot;61 2022 5369&quot; ## ## [[3]] ## [1] &quot;61-2020-8753&quot; ## ## [[4]] ## [1] &quot;61-2022-5835&quot; &quot;19.3237.5344&quot; Note que com str_extract_all(), conseguimos identificar exatamente em que posição do vetor original cada string estava. str_extract_all(strings, phone, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;&quot; &quot;&quot; ## [2,] &quot;61 2022 5369&quot; &quot;&quot; ## [3,] &quot;61-2020-8753&quot; &quot;&quot; ## [4,] &quot;61-2022-5835&quot; &quot;19.3237.5344&quot; str_match() extrai grupos de captura de expressões regulares formados por () apenas para a primeira correspondência. str_match_all() extrai grupos de captura de todos os macthes e retorna uma lista de matrizes de caracteres. # Pull out the three components of the match str_match(strings, phone) ## [,1] [,2] [,3] [,4] ## [1,] NA NA NA NA ## [2,] &quot;61 2022 5369&quot; &quot;61&quot; &quot;2022&quot; &quot;5369&quot; ## [3,] &quot;61-2020-8753&quot; &quot;61&quot; &quot;2020&quot; &quot;8753&quot; ## [4,] &quot;61-2022-5835&quot; &quot;61&quot; &quot;2022&quot; &quot;5835&quot; str_match_all(strings, phone) ## [[1]] ## [,1] [,2] [,3] [,4] ## ## [[2]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;61 2022 5369&quot; &quot;61&quot; &quot;2022&quot; &quot;5369&quot; ## ## [[3]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;61-2020-8753&quot; &quot;61&quot; &quot;2020&quot; &quot;8753&quot; ## ## [[4]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;61-2022-5835&quot; &quot;61&quot; &quot;2022&quot; &quot;5835&quot; ## [2,] &quot;19.3237.5344&quot; &quot;19&quot; &quot;3237&quot; &quot;5344&quot; str_replace() substitui a primeira ocorrência em que houve matching e retorna um vetor de caracteres. str_replace_all() substitui todos os matches. Esta e uma função muito interessante de se usar quando estamos trabalhando com dados identificados e desejamos esconder CPF’s, RG’s, números de telefone, etc. Veja um exemplo com os números de telefone. str_replace(strings, phone, &quot;XX-XXXX-XXXX&quot;) ## [1] &quot;apple&quot; &quot;XX-XXXX-XXXX&quot; ## [3] &quot;XX-XXXX-XXXX&quot; &quot;Trabalho: XX-XXXX-XXXX; Home: 19.3237.5344&quot; str_replace_all(strings, phone, &quot;XX-XXXX-XXXX&quot;) ## [1] &quot;apple&quot; &quot;XX-XXXX-XXXX&quot; ## [3] &quot;XX-XXXX-XXXX&quot; &quot;Trabalho: XX-XXXX-XXXX; Home: XX-XXXX-XXXX&quot; str_split_fixed() divide a string em um número fixo de partes baseado no padrão passado como argumento e retorna uma matriz de caracteres. str_split() separa uma string em um número variável de partes e retorna uma lista de vetores de caracteres. str_split(&quot;a-b-c&quot;, &quot;-&quot;) ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; str_split_fixed(&quot;a-b-c&quot;, &quot;-&quot;, n = 2) ## [,1] [,2] ## [1,] &quot;a&quot; &quot;b-c&quot; 4.1.3.2 Índices e matching: str_subset() permite extrair elementos de um vetor de strings, caso ele contenha o caractere ou grupo de caracteres informado. fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pinapple&quot;) str_subset(fruit, &quot;a&quot;) ## [1] &quot;apple&quot; &quot;banana&quot; &quot;pear&quot; &quot;pinapple&quot; str_which() retorna a posição do vetor-alvo, em que foi encontrada correspondência para um determinado caractere ou conjunto de caracteres informados. str_which(LETTERS, &quot;F&quot;) ## [1] 6 # str_which(LETTERS, &quot;F|Y&quot;) 4.1.4 Referências da seção Wickham, H. (2019). stringr: Simple, Consistent Wrappers for Common String Operations. R package version 1.4.0. https://CRAN.R-project.org/package=stringr. ____. (2020). _stringr vignette: Introduction. URL http://stringr.tidyverse.org Wickham, H.; Grolemund, G. (2016). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. O’Reilly Media. december 2016. 522 pages. Disponível em: www.r4ds.co.nz Estatística Computacional 2 (2015). Notas de aula. Curso de graduação em Estatística. UnB. 1º semestre, 2015. 4.2 Expressões Regulares (REGEX) 4.2.1 Introdução As linguagens de programação possuem mais de um tipo de mecanismo de busca de padrões em strings. Expressões regulares é o mecanismo mais utilizado. Por isso, será o nosso foco neste curso. No entanto, saiba que o pacote stringr também traz implementações dos outros 3 tipos, os quais descrevemos abaixo: Fixed bytewise matching com a função fixed(); Locale-sensitive correspondência de caracteres com coll() (collation search); Text boundary analysis com a função boundary(). Se você se interessar pelo assunto, pode buscar mais informações na documentação do pocote stringr. Mas o que seriam exatamente, então, Expressões Regulares? Expessões Regulares são formas concisas e flexíveis para descrever padrões (que estamos buscando) em strings. Nesta seção, nós vamos descrever os principais aspectos relacionados a construção de expressões regulares. Para isso utilizaremos alguns dos exemplos descritos nas vignettes do pacote stringr e parte de minhas notas de aula do Curso de Computação Estatística da UnB. Primeiro faremos uma introdução geral sobre expressões regulares e depois veremos exemplos utilizando o pacote stringr. Por que expressões regulares são importantes? Expressões regulares nos permitem descrever em termos mais gerais o que desejamos buscar em uma string. Normalmente, é mais eficiente usarmos expressões regulares, porque se buscarmos caracteres simples, só obteremos a correspondência exata para aquele caractere. Já pensou em como faríamos para buscar apenas números de telefone, endereços de e-mail, CNPJ’s ou CPF’s no meio de dados (por exemplo páginas da internet) que não estão exatamente organizados em colunas? Cabe ressaltar que expressões regulares é uma técnica usada praticamente em todo o mundo da programação. Não é uma particularidade somente da linguagem R. As expressões regulares (regex), em geral, são construídas da combinação de 3 componentes: literal characters: que somente vão sofrer matching se houver nos dados caracteres literais idênticos; character classes: que permitem o matching por múltiplos caracteres - são compostas de caracteres dentro de dois colchetes [ ]; modifiers ou anchors: que vão operar nos caracteres, nas classes e em combinações dos dois. 4.2.2 Exemplos de REGEX usando stringr 4.2.2.1 Correspondências literais (basic match/literal characters) O padrão mais simples para fazer o matching é: x &lt;- c(&quot;maçã&quot;, &quot;banana&quot;, &quot;pêra&quot;) str_extract(x, &quot;an&quot;) ## [1] NA &quot;an&quot; NA Podemos ignorar letras maiúsculas e minúsculas com ignore_case = TRUE: bananas &lt;- c(&quot;banana&quot;, &quot;Banana&quot;, &quot;BANANA&quot;) str_detect(bananas, &quot;banana&quot;) ## [1] TRUE FALSE FALSE str_detect(bananas, regex(&quot;banana&quot;, ignore_case = TRUE)) ## [1] TRUE TRUE TRUE Seguindo com os exemplos, o próximo passo é conhecermos o papel desempenhado por .. Sua função é buscar qualquer caractere com exceção de uma nova linha (\\n): str_extract(x, &quot;.a.&quot;) ## [1] &quot;maç&quot; &quot;ban&quot; NA Mas se você quiser encontrar até mesmo caracteres que indicam uma nova linha, pode “setar” dotall = TRUE dentro da função responsável pelo mecanismo de matching, que é a função regex(): str_detect(&quot;\\nX\\n&quot;, &quot;.X.&quot;) ## [1] FALSE str_detect(&quot;\\nX\\n&quot;, regex(&quot;.X.&quot;, dotall = TRUE)) ## [1] TRUE 4.2.2.2 Escaping characters ou caracteres de escape Se . faz o matching de qualquer caractere, como podemos fazer o matching literal de um ponto “.” nos dados? Teremos de usar um caractere de escape para dizer ao R que queremos um matching literal e não usar o comportamento especial de .. Em REGEX, utiliza-se uma barra invertida \\ para tal fim. Então, para buscarmos um simples “.” nos dados, usamos \\.. Mas há um porém: a barra invertida também é tratada como um caractere especial no R quando se trata de strings_. Portanto, teríamos que acrescentar outra barra invertida formando a string \\\\. de modo a fazermos o matching com um simples ponto nos dados. dot &lt;- &quot;\\\\.&quot; # Mas veja que como REGEX, existe somente uma barra: \\. writeLines(dot) ## \\. # Isso diz ao R para buscar explicitamente um ponto str_extract(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;bef&quot;), &quot;a\\\\.c&quot;) ## [1] NA &quot;a.c&quot; NA Para te ajudar a entender quantas barras você precisará escrever no código, vamos pensar que existem dois mecanismos diferentes: o interpretador do R e o mecanismo do REGEX. Quando você envia uma expressão regular para o interpretador, ele passará por um filtro em que serão aplicadas as regras do R. Passado esse primeiro filtro, a expressão segue para uma nova instância, onde sofrerá ação do mecanismo de REGEX. Pense nessas etapas como um pedágio. Para cada barra invertida que precisa chegar na última etapa do pedágio, você precisa também de uma barra \\ para “pagar o pedágio” da primeira etapa. As barras invertidas \\, são, portanto, a sua moeda de troca e você não pode levar nem mais nem menos “dinheiro” do que precisa. Se a expressão tem que chegar na etapa de REGEX como \\., para que a última barra seja encarada como um caractere especial que descaracteriza o funcionamento especial do ., fazendo assim um matching literal, você precisa enviar uma barra \\ a mais para que seja consumida na etapa do interpretador do R. Por isso, no seu código, você deve escrever \\\\.. Já pensou, então, em como faríamos para fazer o matching literal de uma barra invertida em uma string? Vamos pensar novamente como um pedágio, começando da última etapa para primeira. No mecanismo de REGEX, última etapa do pedágio, a expressão deve chegar com duas barras \\\\: a da esquerda fazendo função de caractere especial, que elimina a função especial da barra da direita. Portanto, para carregar duas barras até o final do processo, você precisa de outras duas barras \\\\ para serem consumidas na etapa do interpretador do R. Portanto, para fazer o matching literal de uma barra invertida em uma string, seu código deve ser escrtio como \\\\\\\\. O que acontece, na verdade, é que o interpretador separa cada par de barras, fazendo com que a da esquerda tire o funcionamento especial da barra da direita em cada par. Desta forma, chegam apenas duas barras no mecanismo de REGEX. x &lt;- &quot;a\\\\b&quot; writeLines(x) ## a\\b str_extract(x, &quot;\\\\\\\\&quot;) ## [1] &quot;\\\\&quot; A partir de agora, quando formos nos referir à expressões regulares, usaremos a forma apenas com uma \\. No entanto, saiba que em seu código nas funções do R, você deverá adicionar mais uma barra invertida \\\\. 4.2.2.3 Matching de múltiplos caracteres (classes) Primeiro, veremos alguns atalhos para classes de caracteres: atalhos classes \\w alfanuméricos e _ (qualquer palavra) \\W não-alfanuméricos (qualquer coisa diferente de palavras e _) \\d digitos \\D não-dígitos \\s espaço \\S não-espaço Passemos aos exemplos: str_extract_all(&quot;Don&#39;t eat that!&quot;, &quot;\\\\w+&quot;)[[1]] ## [1] &quot;Don&quot; &quot;t&quot; &quot;eat&quot; &quot;that&quot; str_split(&quot;Don&#39;t eat that!&quot;, &quot;\\\\W&quot;)[[1]] ## [1] &quot;Don&quot; &quot;t&quot; &quot;eat&quot; &quot;that&quot; &quot;&quot; str_extract_all(&quot;1 + 2 = 3&quot;, &quot;\\\\d+&quot;)[[1]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; (text &lt;- &quot;Texto \\t com\\n\\t\\tespaçamento \\f ruim&quot;) ## [1] &quot;Texto \\t com\\n\\t\\tespaçamento \\f ruim&quot; str_replace_all(text, &quot;\\\\s+&quot;, &quot; &quot;) ## [1] &quot;Texto com espaçamento ruim&quot; Um outro atalho interessante é \\b que busca por limites/bordas de palavras, ou seja, transições entre caracteres de palavras e caracteres de não-palavras. \\B faz o oposto. str_replace_all(&quot;The quick brown fox&quot;, &quot;\\\\b&quot;, &quot;_&quot;) ## [1] &quot;_The_ _quick_ _brown_ _fox_&quot; str_replace_all(&quot;The quick brown fox&quot;, &quot;\\\\B&quot;, &quot;_&quot;) ## [1] &quot;T_h_e q_u_i_c_k b_r_o_w_n f_o_x&quot; Você pode consultar outros atalhos interessantes nesta vignette do pacote stringr. Há a possibilidade, ainda, de criarmos nossas próprias classes usando []: [abc]: busca a correspondência de a, b ou c; [a-z]: busca qualquer caractere minúsculo entre a e z; [A-Z]: busca qualquer caractere maiúsculo entre A e Z; [^abc]: busca qualquer coisa exceto a, b, ou c; [\\^\\-]: busca ^ ou -. Lembre-se de adicionar mais uma barra invertida na frente de cada uma das barras ao passar o comando no R) Há ainda diversas classes pré-construídas que podemos usar com os colchetes: [:punct:]: pontuação; [:alpha:]: letras; [:lower:]: letras minúsculas; [:upper:]: LETRAS MAIÚSCULAS; [:digit:]: digitos; [:alnum:]: letras e números. [:cntrl:]: caracteres de controle. [:graph:]: letras, números e pontuação. [:print:]: letras, números, pontuação e espaço em branco. [:space:]: caracteres de espaço (equivalente a \\s). [:blank:]: espaço e tab. Essas expressões vão dentro de outros colchetes: y &lt;- c(1234, &quot;R&quot;, &quot;IPEA&quot;, &quot; &quot;, &quot;Olá, tudo bem ?&quot;) str_extract_all(y, &quot;[[:digit:]]&quot;) ## [[1]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ## ## [[2]] ## character(0) ## ## [[3]] ## character(0) ## ## [[4]] ## character(0) ## ## [[5]] ## character(0) str_extract_all(y, &quot;[[:digit:]á]&quot;) ## [[1]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ## ## [[2]] ## character(0) ## ## [[3]] ## character(0) ## ## [[4]] ## character(0) ## ## [[5]] ## [1] &quot;á&quot; str_extract_all(y, &quot;[[:digit:]td]&quot;) ## [[1]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ## ## [[2]] ## character(0) ## ## [[3]] ## character(0) ## ## [[4]] ## character(0) ## ## [[5]] ## [1] &quot;t&quot; &quot;d&quot; str_extract_all(y, &quot;[b[:upper:]m]&quot;) ## [[1]] ## character(0) ## ## [[2]] ## [1] &quot;R&quot; ## ## [[3]] ## [1] &quot;I&quot; &quot;P&quot; &quot;E&quot; &quot;A&quot; ## ## [[4]] ## character(0) ## ## [[5]] ## [1] &quot;O&quot; &quot;b&quot; &quot;m&quot; 4.2.2.4 Operador Alternation | é o operador de alternância que permite escolher entre uma ou mais correspondências possíveis. abc|def vai fazer o matching com abc ou def. str_detect(c(&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;), &quot;abc|def&quot;) ## [1] TRUE TRUE FALSE 4.2.2.5 Agrupamento Parenteses podem servir para alterar regras de precedência ou formar grupos. O mesmo que vimos no Módulo 1 para alterar regras de precedência serve para REGEX: str_extract(c(&quot;grey&quot;, &quot;gray&quot;), &quot;gre|ay&quot;) ## [1] &quot;gre&quot; &quot;ay&quot; str_extract(c(&quot;grey&quot;, &quot;gray&quot;), &quot;gr(e|a)y&quot;) ## [1] &quot;grey&quot; &quot;gray&quot; Parênteses definem grupos e podemos retro-referenciar esses grupos utilizando \\Nro_do_grupo para indicar que os grupos podem se repetir mais vezes, bem como a ordem na qual se repetiriam na string. pattern &lt;- &quot;(1|2)(3|4)\\\\1&quot; combinacoes &lt;- list(&quot;1213&quot;, &quot;1413&quot;, &quot;2324&quot;, &quot;1111&quot;, &quot;2222&quot;, &quot;1415&quot;, &quot;1313&quot;, &quot;1331&quot;) combinacoes %&gt;% str_subset(pattern) ## [1] &quot;1413&quot; &quot;2324&quot; &quot;1415&quot; &quot;1313&quot; pattern2 &lt;- &quot;(1|2)(3|4)\\\\1\\\\2&quot; combinacoes %&gt;% str_subset(pattern2) ## [1] &quot;1313&quot; pattern3 &lt;- &quot;(1|2)(3|4)\\\\2\\\\1&quot; combinacoes %&gt;% str_subset(pattern3) ## [1] &quot;1331&quot; # OU # combinacoes %&gt;% # str_subset(pattern) %&gt;% # str_match(pattern) 4.2.2.6 Âncoras ou modificadores Ancorar significa estabelecer um padrão para o início ou final da string que estamos buscando. ^ busca o padrão no começo da string; $ busca o padrão no final da string. x &lt;- c(&quot;maçã&quot;, &quot;banana&quot;, &quot;pêra&quot;) str_extract(x, &quot;^m&quot;) ## [1] &quot;m&quot; NA NA str_extract(x, &quot;a$&quot;) ## [1] NA &quot;a&quot; &quot;a&quot; 4.2.2.7 Repetições Pode-se controlar quantas vezes um padrão aparece em determinada parte da string com: ?: 0 ou 1. +: 1 ou mais. *: 0 ou mais. x &lt;- &quot;1888 é o ano mais longo em algarismos romanos: MDCCCLXXXVIII&quot; str_extract(x, &quot;CC?&quot;) ## [1] &quot;CC&quot; str_extract(x, &quot;CC+&quot;) ## [1] &quot;CCC&quot; str_extract(x, &#39;C[LX]+&#39;) ## [1] &quot;CLXXX&quot; str_match(&quot;banana&quot;, &#39;(na)+&#39;) ## [,1] [,2] ## [1,] &quot;nana&quot; &quot;na&quot; Podemos especificar o número exato de repetições que esperamos com: {n}: exatamente \\(n\\) vezes; {n,}: \\(n\\) vezes ou mais; {n,m}: entre \\(n\\) e \\(m\\) vezes. str_extract(x, &quot;C{2}&quot;) ## [1] &quot;CC&quot; str_extract(x, &quot;C{2,}&quot;) ## [1] &quot;CCC&quot; str_extract(x, &quot;C{2,3}&quot;) ## [1] &quot;CCC&quot; Há diversos outros padrões e expressões que podem ser usadas. Busque ??stringi_search-regex ou visite o site de stringr. 4.2.3 Referências da seção Wickham, H. (2019). stringr: Simple, Consistent Wrappers for Common String Operations. R package version 1.4.0. https://CRAN.R-project.org/package=stringr. ____. (2020). _stringr vignette: Introduction. URL http://stringr.tidyverse.org Wickham, H.; Grolemund, G. (2016). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. O’Reilly Media. december 2016. 522 pages. Disponível em: www.r4ds.co.nz Estatística Computacional 2 (2015). Notas de aula. Curso de graduação em Estatística. UnB. 1º semestre, 2015. 4.3 Relatórios e pesquisa reproduzível com rmarkdown 4.3.1 Introdução Chegamos a um ponto do curso em que já possuímos um ferramental poderoso para analisar e tratar dados. No entanto, nos dias atuais, há uma outra etapa tão importante quanto as anteriores na Ciência de Dados: compartilhar e comunicar suas análises. Para este objetivo, o R certamente é a ferramenta mais poderosa nos dias atuais: você pode integrar desde a etapa de análise de dados até o compartilhamento de seus códigos, gráficos e constatações por meio de relatórios, slides, artigos em \\(\\TeX\\) e até mesmo livros. Esta apostila mesmo foi toda confeccionada dentro da linguagem R. Nesta seção, vamos focar na produção de relatórios. Veremos também como confeccionar esses relatórios de modo que eles se adequem automaticamente a mudanças nos dados que originam sua análise. Além dessa questão prática, todos os dados e códigos utilizados numa análise podem ser compartilhados com sua equipe, o que reforça o carater de reproducibilidade da linguagem R. Qualquer outra pessoa poderá facilmente replicar e verificar/validar os resultados obtidos por você. A ferramenta que nos permite fazer a maioria dessas coisas que citamos acima é o pacote rmarkdown. Ele é um pacote que gravita em torno do core do tidyverse. O rmarkdown une escrita de texto e de códigos num único lugar, por meio de linaguagem de marcação (markdown). A linguagem de marcação possui uma sintaxe bastante simples e que torna a produção de texto bem ágil, diferentemente do que ocorre com \\(HTML\\) e \\(\\LaTeX\\), por exemplo. Isso faz com que você não precise sair do RStudio ou mesmo trocar de janela ou abas para incluir texto, figuras, outputs ou pedaços (chunk) de códigos em um documento do tipo R Markdown. O pacote rmarkdown é tão supreendente que a partir dele surgiram pacotes derivados que permitem a criação de sites e blogs com blogdown (veja https://allanvc.github.io) e a confecção de livros e apostilas como esta que você está lendo por meio do pacote bookdown, além de outros. Para começar a confecionar um relatório em R Markdown, você precisa criar um novo arquivo do tipo .Rmd. Clique em , como você normalmente faz para criar um script, só que, desta vez selecione “R Markdown” . Uma nova janela será aberta no RStudio, em que você deverá escolher que tipo de arquivo de output deseja, se HTML, PDF ou .docx, bem como seu nome e o título do seu relatório. Vamos escolher PDF. Note que automaticamente será criada uma nova aba no RStudio, com um modelo de relatório .Rmd pré-formatado. ATENÇÃO: Se esta for sua primeira vez utilizando R Markdown no Windows, o próprio RStudio irá oferecer a instalação de alguns pacotes necessários (e suas dependências) para rodarmos o rmarkdown. Dentre eles estará o pacote tinytex. Trata-se de um pacote que realiza a instalação mínima de bibliotecas \\(\\LaTeX\\) necessárias para a geração de documentos .pdf a partir do R Markdown. Após a instalação dos pacotes, basta executar no console o código abaixo e depois reiniciar sua sessão do RStudio. tinytex::install_tinytex() Na aba criada, estão todos os dados que você informou anteriormente e também uma série de exemplos criados automaticamente retratando o funcionamento de um simples relatório em R Markdown. Note que todo o texto é editável. Os documentos são gerados utilizando o pacote knitr. Este pacote funciona como um pacote de apoio de rmarkdown, mas você não precisa conhecê-lo a fundo. Knit em inglês significa tricotar ou unir. E é justamente isso que ele faz, ele costura e une todos os elementos que você vier a construir ou programar com R Markdown. Se você já quiser gerar um relatório a partir do exemplo apresentado a você ao criar um novo arquivo .Rmd, você podê fazê-lo clicando no botão Knit na janela do RStudio. Após escolher um nome e salvar seu arquivo .Rmd, se você escolheu a opção PDF, você terá um arquivo de extensão .pdf. Faça testes alterando os arquivos de destino: .html e .docx direto no botão Knit. DICA: A cada comando novo que você aprender ao longo dessa seção, sugerimos gerar um novo relatório, de modo que você possa companhar as modificações feitas no documento. Por isso, sugerimos também que você apague todo o conteúdo do relatório de sugestão criado ao abrir um novo documento .Rmd, mantendo somente os dados do cabeçalho: title, author, date e output. 4.3.2 Cabeçalho No cabeçalho você pode especificar todos os aspectos técnicos de formatação do seu texto em R Markdown. Existem diversas opções, mas focaremos nas mais básicas que são as que aparecem na tela neste momento. title contém o título de seu documento; author o seu nome; date a data de geração do documento; output o tipo de documento a ser gerado, se HTML, PDF ou Word. Alguns truques úteis: Caso você queira acrescentar um co-autor, use: author: - Nome do Autor1 - Nome do Autor2 Para adicionar um subtítulo, basta escrever: title: &quot;Seu Título&quot; subtitle: &quot;Subtítulo para o relatório&quot; Para não ter que ficar alterando a data manualmente, toda vez que você executa o Knit, utiliza a função format() em conjunto com Sys.time(). Note que esse código é passado entre sinais de crase ``. date: &quot;`r format(Sys.time(), &#39;%d %B %Y&#39;)`&quot; 4.3.3 Formatação de Texto A sintaxe de formatação de texto do R Markdown é muito simples. Por isso a produção de textos com ele é muito rápida. Isso vem com o custo de não se ter tanta flexibilidade de alteração de elementos textuais como numa linguagem como \\(\\LaTeX\\), mas ainda sim, as possibilidades de formatação são bem consideráveis. 4.3.3.1 Títulos O símbolo # é utilizado para definir títulos. A cada # acrescentado, você desce uma hierarquia e cria um subtítulo do título anterior. Quanto menos # houver antes do seu título, maior a hierarquia e consequentemente maior a fonte. # Título do Artigo ## Subtítulo ### Seção #### Subseção 4.3.3.2 Parágrafos Para redigir um parágrafo basta começar a escrever um texto qualquer. Para adicionar parágrafos basta pular uma linha, deixando um espaço em branco entre os parágrafos Este é o primeiro parágrafo do seu texto. Você pode escrever normalmente e ele aparecerá no seu relatório. Após pular uma linha, você começa um novo parágrafo. Acrescente as ideias que você desejar neste segundo parágrafo 4.3.3.3 Formatação da fonte Você pode aplicar formatações em itálico e negrito à palavras espécificas, expressões ou trechos completos de seu texto, colocando a palvra ou trecho em questão entre asteriscos. Para formatação em negrito, utilize **palavra ou trecho**: palavra ou trecho. Para a formatação em itálico, utilize *palavra ou trecho*: palavra ou trecho. Você pode obter o mesmo efeito utilizando underline no lugar dos asteriscos, como nestes exemplos _palavra ou trecho_: palavra ou trecho; e __palavra ou trecho__: palavra ou trecho. 4.3.3.4 Notas de rodapé Notas de rodapé podem ser inseridas no testo utilizando o esquema palavra^[Texto que irá para a nota de rodapé sobre a palavra.] Nesse texto vamos inserir uma nota de rodapé sobre a palavra Estatística^[Estatística é a disciplina que consiste na coleta, organização, análise e apresentação de dados.] 4.3.3.5 Confecção de listas e enumeração de itens 4.3.3.5.1 Listas não-numeradas Para criar listas não-numeradas, podemos utilizar tanto * quanto -: * item X * item Y * item Z item X item Y item Z - item X - item Y - item Z item X item Y item Z Nas listas não-numeradas, para criar subitens, você deve dar 4 espaços ou TAB a partir da margem esquerda e utilizar - ou +: * item X - subitem * item Y - subitem + subsubitem * item Z + subitem + subitem item X subitem item Y subitem subsubitem item Z subitem subitem 4.3.3.5.2 Listas numeradas Para criar listas numeradas, utilizamos o numeral acompanhado de ponto: 1., 2., 3. e assim por diante. Para a criação de subitens, no caso de listas numeradas, utilize dois TAB ou 4 espaços seguido de -. 1. item A - subitem 2. item B - subitem - subitem 2. item C - subitem - subitem item A subitem item B subitem subitem item C subitem subitem 4.3.3.6 Tabelas Tabelas podem ser adicionadas utilizando | para separar as colunas e ------ para separar o cabeçalho, contendo os nomes das colunas. Note que os as barras retas que separam as colunas devem estar alinhadas. coluna1 | coluna2 | coluna3 --------|----------|-------- Nome1 | Endereço1| Valor1 Nome2 | Endereço2| Valor2 Nome3 | Endereço3| Valor3 coluna1 coluna2 coluna3 Nome1 Endereço1 Valor1 Nome2 Endereço2 Valor2 Nome3 Endereço3 Valor3 4.3.4 Inserção de figuras externas Você pode incluir em seu relatório figuras externas, ou seja, figuras que não são geradas a partir do R. Você pode referenciar tanto figuras que estão armazenadas localmente em sua máquina, quanto figuras disponíveis na web. ![Descrição Figura Web](https://www.r-project.org/Rlogo.png) ![Logo de um dos meus pacotes](./fig/mRpostman_logo.png) Descrição Figura Web Logo de um dos meus pacotes 4.3.5 Inserção de links O processo de inserção de links, segue uma abordagem muito parecida a de inserção de figuras externas. A diferença é que você não precisará mais de !. Além disso, apenas o texto dentro dos colchetes [] é que aparecerá ao leitor. Ao ser clicado, ele será direcionado para o link a ser passado dentro dos parênteses (). Clique neste [LINK](https://allanvc.github.io). Arquivo disponível em [https://allanvc.github.io](https://allanvc.github.io). Clique neste LINK. Arquivo disponível em https://allanvc.github.io. 4.3.6 Fórmulas matemáticas Você pode inserir fórmulas matemáticas utilizando os princípios de \\(\\LaTeX\\). Veja a função densidade de probabilidade de uma distribuição Normal. Para isso, você deve passar a fórmula entre $$ duplos. Note como a formatação fica elegante. $$ f(x;\\mu,\\sigma^2) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{ -\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2 } $$ \\[ f(x;\\mu,\\sigma^2) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{ -\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2 } \\] Se você quiser apresentar alguma fórmula no meio do texto de um parágrafo, passe a fórmula apenas entre dois $ simples: A função densidade de probabilidade da Distribuição Normal é dada por $f(x;\\mu,\\sigma^2) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{ -\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2 }$. A função densidade de probabilidade da Distribuição Normal é dada por \\(f(x;\\mu,\\sigma^2) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{ -\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2 }\\). 4.3.7 Inserção e execução de códigos A maior vantagem de R Markdown provavelmente é a possibilidade de juntarmos, código, outputs e texto tudo no mesmo lugar de forma muito simples e natural. 4.3.7.1 Inserção simples Para apresentar o seu código ao longo de uma linha, sem necessariamente executá-lo, utilize crases simples. No R, podemos criar um vetor numérico x através do código `x &lt;- c(1:10)`. No R, podemos criar um vetor numérico x através do código x &lt;- c(1:10). Se precisamos apresentar um trecho maior de código, podemos fazê-lo entre crases triplas ```, formado um bloco: Esse é um trecho de código maior: ``` x &lt;- c(1:10) sum(x) ``` O que resulta em: Esse é um trecho de código maior: x &lt;- c(1:10) sum(x) 4.3.7.2 Inserções com execução e outros controles Para começar a apresentar seus códigos juntamente com os respectivos outputs (o que incluem gráficos), utilizamos o que chamamos de chunks, que nada mais são que pedaços de códigos a serem executados durante o processamento do documento. rmarkdown e sua interação com o RStudio são tão sofisticados que, se você possuir outras linguagens instaladas na sua máquina, você consegue inclusive, alterar a forma de exibição de linguagem R para Python por exemplo. No entanto, nosso foco será apenas na configuração dos parâmetros mais utilizados. Inicialmente, para criar um chunk de código R, você deve utilizar as mesmas crases triplas ``` do exemplo anterior, acompanhadas da anotação {r}. Não se esqueça de fechar o chunk com as mesmas aspas triplas. ```{r} x &lt;- 1:10 sum(x) ``` Como resultado, temos agora a impressão do output do código anterior: x &lt;- 1:10 sum(x) ## [1] 55 DICA: Também é possível executar trechos de código inline, no meio dos parágrafos. Para isso, utilizamos `r sum(x)` Por exemplo: A soma do vetor x é `r sum(x)`. O que resulta em: A soma do vetor x é 55. 4.3.7.2.1 Principais opções de chunk As principais opções de chunk são: results: especifica como, e se, serão mostrados os resultados do chunk; opções: markup (default): exibe os resultados normalmente hide: não exibe os outputs no relatório final hold: exibe os resultados apenas ao final do relatório asis: não reformata os resultados, exibindo (útil quando os outputs são códigos HTML, por exemplo) echo: especifica se o código do chunk deve será exibido opções: TRUE (default): exibe os códigos acima do output FALSE: exibe apenas o output gerado pelo chunk eval: especifica se o chunk será executado ou não opções: TRUE (default): executa o chunk FALSE: não executa o chunk (útil quando desejamos exibir apenas os códigos e não seu output) message e warning: define se as mensagens e demais avisos gerados durante a excução do código opções: TRUE (default): exibe mensagens e avisos gerados durante a excução do chunk FALSE: suprime a exibição de mensagens e warnings (útil para suprimir mensagens de carregamento de pacotes) fig.cap: especifica uma descrição para a figura gerada no chunk fig.align: define o alinhamento da figura gerada no chunk opções: center (default): alinhamento no centro do documento left: alinhamento à esquerda right: alinhamento à direita fig.height e fig.width: define a altura e a largura da figura em polegadas - default é tamanho 7 Se nada for especificado para uma determinada opção, as configurações default são utlizadas na avaliação do código e exibição dos resultados. Essas opções devem ser passadas no cabeçalho dos chunks, ao lado da letra r e dentro de das chaves {}, por exemplo: ```{r, echo=FALSE, message=FALSE} library(dplyr) x &lt;- 1:10 x %&gt;% sum() ``` Você pode também atribuir nomes aos seus chunks. Isso é bastante recomendado quando se está produzindo relatórios relativamente grandes com vários chunks, pois facilitará a identificação de eventuais erros durante o processo de geração do documento. Os nomes devem ser informados antes da primeira vírgula, a um espço de distância da letra r: {r nome_do_chunk, opções} Vejamos alguns exemplos, em que criamos alguns chunks com nome, para realizar a leitura de uma das bases dos módulos anteriores e plotarmos um gráfico utilizando gggplot2: ```{r leitura, message=FALSE} library(readr) library(dplyr) tb_ibama &lt;- read_csv(file=&quot;https://raw.githubusercontent.com/allanvc/book_IADR-T/master/datasets/PA%20GF%202017%20jan-jun_editada.csv&quot;, col_types = cols( X1 = col_double(), TIPO_GF = col_character(), STATUS_GF = col_character(), UF_REMETENTE = col_character(), MUNICÍPIO_REMETENTE = col_character(), TIPO_DESTINO = col_character(), CEPROF_DESTINATÁRIO = col_character(), UF_DESTINATÁRIO = col_character(), MUNICÍPIO_DESTINATÁRIO = col_character(), N_AUTORIZAÇÃO = col_character(), PROCESSO = col_character(), EMISSAO = col_integer(), NOME_CIENTÍFICO = col_character(), PRODUTO = col_character(), VOLUME = col_double(), UNID = col_character(), PRECO_TOTAL = col_double() ) ) tb_ibama$STATUS_GF[1:50000] &lt;- rep(&quot;NÃO VERIFICADO&quot;, 50000) tb_ibama2 &lt;- mutate(tb_ibama, preco_unidade = PRECO_TOTAL / VOLUME, preco_unidade_vezes_1000 = preco_unidade * 1000 ) ``` ```{r plot, fig.cap=&quot;Fonte: Ibama&quot;, fig.height=5, fig.width=5, fig.align=&quot;left&quot;} library(ggplot2) tb_ibama2 %&gt;% ggplot()+ geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, colour=TIPO_GF))+ labs(title=&quot;Título do gráfico&quot;, x = &quot;Rótulo eixo x&quot;, y = &quot;Rótulo eixo y&quot;, colour = &quot;Título da Legenda&quot;)+ theme_bw() ``` O que resultaria em: library(readr) library(dplyr) tb_ibama &lt;- read_csv(file=&quot;https://raw.githubusercontent.com/allanvc/book_IADR-T/master/datasets/PA%20GF%202017%20jan-jun_editada.csv&quot;, col_types = cols( X1 = col_double(), TIPO_GF = col_character(), STATUS_GF = col_character(), UF_REMETENTE = col_character(), MUNICÍPIO_REMETENTE = col_character(), TIPO_DESTINO = col_character(), CEPROF_DESTINATÁRIO = col_character(), UF_DESTINATÁRIO = col_character(), MUNICÍPIO_DESTINATÁRIO = col_character(), N_AUTORIZAÇÃO = col_character(), PROCESSO = col_character(), EMISSAO = col_integer(), NOME_CIENTÍFICO = col_character(), PRODUTO = col_character(), VOLUME = col_double(), UNID = col_character(), PRECO_TOTAL = col_double() ) ) tb_ibama$STATUS_GF[1:50000] &lt;- rep(&quot;NÃO VERIFICADO&quot;, 50000) tb_ibama2 &lt;- mutate(tb_ibama, preco_unidade = PRECO_TOTAL / VOLUME, preco_unidade_vezes_1000 = preco_unidade * 1000 ) library(ggplot2) tb_ibama2 %&gt;% ggplot()+ geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, colour=TIPO_GF))+ labs(title=&quot;Título do gráfico&quot;, x = &quot;Rótulo eixo x&quot;, y = &quot;Rótulo eixo y&quot;, colour = &quot;Título da Legenda&quot;)+ theme_bw() Figure 4.1: Fonte: Ibama 4.3.8 Tabelas mais sofisticadas Quando usamos um tibble ou data frame e o output de destino é um arquivo HTML, nos beneficiamos do fato de o R Markdown reconhecer o formato e imprimir o conteúdo do tibble ou data frame como uma tabela do R Markdown. Para isso basta incluir as seguintes linhas no cabeçalho YAML, alterando para paged, kable ou tibble. Vamos ver um exemplo com paged --- title: &quot;Título&quot; output: html_document: df_print: &lt;opção&gt; --- Vamos utilizar a opção df_print: paged, que vai fazer com a tabela seja imprida de forma paginada, exibindo apenas algumas linhas (e colunas) de cada vez e, permitindo aos usuários navegarem por seu conteúdo de forma interativa. Após alterar o cabeçalho, basta chamar o objeto tb_ibama2 de dentro de um chunk. ```{r tabela, cols.print = 5, rows.print = 5} tb_ibama2 ``` Note que os argumentos cols.print e rows.print controlam o número de colunas e linhas a serem exibidos em cada paginação. O resultado será o seguinte: DICA: Se você deseja controlar melhor o output das tabelas, ou busca gerar tabelas mais sofisticadas em relatórios PDF ou Word, podemos utilizar a função knitr::kable dentro de um chunk do R Markdown. knitr::kable(tb_ibama2[1:5, 1:5], format = &quot;latex&quot;) No código acima, apresentamos um extrato dos dados (5 primeiras linhas e 5 primeiras colunas) do data frame de nome tb_ibama2 que utilizamos ao longo do curso. A opção format = latex é adequada para a produção de tabelas no estilo \\(\\LaTeX\\). Se objetivo for deixar a tabela com uma aparência ainda melhor você pode utilizar a opção booktabs = TRUE, o que faz com que a engine do pandoc utilize o pacote \\(\\LaTeX\\) booktabs para gerar a tabela. Há diversas outras opções para melhorar ainda mais o estilo da tabela, como acrescentar notas de rodapé, títulos, cores, etc. Para isso você deve investigar outras opções da própria função kable e o pacote kableExtra que amplia as possibilidades de customização. 4.3.9 Referências da seção Allaire, J. J.; Xie, Y.; McPherson, J.; Luraschi, J.; Ushey, K.; Atkins, A.; Wickham, H.; Cheng, J.; Chang, W.; Iannone, R. (2019). rmarkdown: Dynamic Documents for R. R package version 1.13. URL https://rmarkdown.rstudio.com. Xie, Y. (2019). R MArkdown Cookbook. CRS Press. Disponível em: https://bookdown.org/yihui/rmarkdown-cookbook/ Xie Y.; Allaire, J. J.; Grolemund, G. (2018). R Markdown: The Definitive Guide. Boca Raton, Florida: Chapman; Hall/CRC. Disponível em: https://bookdown.org/yihui/rmarkdown. Mayer F.; Zeviani, W. (2019). Pandoc e Markdown. Cursos. UFPR. Disponível em: http://cursos.leg.ufpr.br/prr/capMarkdown.html#. R MARKDOWN REFERENCE GUIDE. Disponível em: https://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf. 4.3.10 Exercícios Escolha um relatório no qual você trabalhou recentemente e tente reproduzir todo ele ou apenas um trecho utilizando os conhecimentos de R Markdown. Dê preferência a trabalhos que envolvam dados que permitam a aplicação daq maior parte das técnicas vistas ao longo do curso. "],["m5.html", " 5 Extra 5.1 Análise Econômica Regional com pacote REAT", " 5 Extra 5.1 Análise Econômica Regional com pacote REAT 5.1.1 Introdução Nesta seção, introduzeremos ao leitor as possibilidades de se realizar análises econômicas regionais no R, utilizando o pacote REAT - Regional Economic Analysis Toolbox. Este pacote fornece métodos para: Identificar disparidades regionais, por meio de indicadores de concentração e/ou dispersão; Medir disparidades regionais ao longo do tempo; Medir aglomerações, isto é, especialização de regiões e concentração espacial industrial; medidas pontuais de clusterização e acessibilidade; crescimento regional, especialmente análise shift_share. Infelizmente, nem todas as funcionalidades do pacote REAT, poderão ser abordadas nesta apostila, mas você poderá sempre recorrer a documentação do pacote e de outros para utilizar outras funcionalidades que possa vir a utilizar no futuro. 5.1.2 Concentração e dispersão Antes de tudo vamos instalar e carregar o pacote: install.packages(&quot;REAT&quot;) library(REAT) Todas as funções que calculam medidas de concentração/dispersão presentes no pacote REAT funcionam de forma semelhante: elas precisam de pelo menos um argumento, um vetor numérico de tamanho \\(n\\), contendo a variável de interesse x (ex: renda) com \\(i\\) observações (ex: regiões), onde \\(i = 1,...,n\\). Estes dados podem ser vetores distintos ou colunas de uma tibble, data frame ou matriz. Pode ser utilizado ainda o argumento opcional weighting, que atribui pesos a variável x, dependendo do valor de \\(i\\). O argumento weighting também deve ser um vetor numérico de tamanho \\(n\\). 5.1.2.1 Aplicação Para a prática, vamos utilizar dados que acompanham o pacote REAT, referentes à inequidade de oferta de serviços de saúde em dois condados alemães: Göttingen (Goettingen) e Northeim. O dataset GoettinggenHealth2 contém os dados de oferta de serviços de saúde, tamanho de população e localização geográfica de 420 distritos. Inicialmente, carregamos o dataset e verificamos a estrutura de nossos dados. data(GoettingenHealth2) str(GoettingenHealth2) ## &#39;data.frame&#39;: 420 obs. of 7 variables: ## $ district: int 1 2 3 4 5 6 7 8 9 10 ... ## $ pop : num 3102 995 310 446 617 ... ## $ lat : num 51.6 51.6 51.6 51.6 51.5 ... ## $ lon : num 9.75 9.78 9.72 9.81 9.74 ... ## $ phys_gen: num 4 1 0 0 1 0 0 1 0 0 ... ## $ psych : num 0 0 0 0 0 0 0 0 0 0 ... ## $ pharm : num 1 0 0 0 0 0 0 1 0 0 ... As colunas phys_gen, psych e pharm contém as respectivas quantidades de médicos, pscioterapeutas (psicólogos) e farmácias por distrito. Estas são as variáveis de interesse para a análise das disparidades regionais entre os distritos. Primeiramente, calculamos o coeficiente de Gini e o índice de Herfindahl-Hirschman para a concentração de clínicos gerais, utilizando respectivamente a função gini() e herf(): gini(GoettingenHealth2$phys_gen) ## [1] 0.8386269 herf(GoettingenHealth2$phys_gen) ## [1] 0.01528053 O Gini próximo a \\(1\\) e o HHI acima de \\(1/N = 1/420 =\\) 0.002381 indicam sensível desigualdade entre os \\(420\\) distritos do dataset. Você pode calcular também as versões normalizadas de ambos os coeficientes/índices. Para isso, basta acrescentar o argumento coefnorm=TRUE. gini(GoettingenHealth2$phys_gen, coefnorm=TRUE) ## [1] 0.8406284 herf(GoettingenHealth2$phys_gen, coefnorm=TRUE) # agora 0 &lt;= HHI &lt;= 1 ## [1] 0.01293036 ATENÇÃO: Particularmente no cálculo do coeficiente de Gini (não normalizado) para concentração, o valor máximo do coeficiente não é exatmente \\(1\\), mas sim \\(1 - \\frac{1}{n}\\), devido à derivação de seu cálculo ter como base a área estabelecida pela curva de Lorenz. Se considerarmos a situação extrema em que uma única pessoa se apropria de toda a renda e as demais \\(n-1\\) pessoas não recebem nada, a área de desigualdade será um triângulo com base \\(1-\\frac{1}{n}\\) no eixo das abscissas e altura \\(h=1\\). Neste caso, o índice de Gini será dado por \\(G=\\frac{\\alpha}{0.5}=2\\alpha\\), sendo \\(\\alpha\\) a área de desigualdade e \\(0,5\\) o valor máximo atingido por \\(\\alpha_{max}=\\frac{1}{2}\\big(1-\\frac{1}{n}\\big)\\) quando o tamanho da população \\(n\\) tende ao infinito: \\(\\lim_{n\\to\\infty}{\\alpha_{max} = \\lim_{n\\to\\infty}{\\frac{1}{2}\\big(1-\\frac{1}{n}}\\big)} = 0,5\\) . Como \\(0\\le \\alpha \\le \\frac{1}{2}\\big(1-\\frac{1}{n}\\big)\\) e \\(G = 2\\alpha\\), temos o índice de Gini variando no intervalo \\(0 \\le G \\le \\big(1-\\frac{1}{n}\\big)\\). Por isso, o índice de Gini só poderá ter máximo igual a \\(1-\\frac{1}{n}\\), no caso de seu cálculo exato a partir da Curva de Lorenz. Isso faz com que seja possível calcular uma versão normalizada do coeficiente fazendo \\(\\frac{n}{n-1}G\\). Dessa forma o índice passa a variar no intervalo \\([0,1]\\). Para saber mais sobre a metodologia de cálculo, recomendam-se as referências desta seção, mais especificamente Hoffman (1998). Cabe destacar que é possível calcular-se o coeficiente de Gini utilizando outras abordagens. Para as demais aplicações (por exemplo npivel de especialização industrial), o pacote REAT empregará outra metodologia de cálculo (funções gini.spec() e gini.conc() para concentração espacial), em que o índice varia exatamente no intervalo \\([0,1]\\). Para checar a concentração graficamente, podemos plotar uma Curva de Lorenz rapidamente utilizando a função lorenz() ou mesmo a função gini(x, lc=TRUE). Os argumentos são os mesmos. A diferença é que a função lorenz() traz apenas o gráfico ao passo que gini(x, lc=TRUE) plota o gráfico e imprime na tela o índice de gini para a variável de interesse. lorenz(GoettingenHealth2$phys_gen) Com gini(x, lc=TRUE, add.lc=TRUE, ...)Podemos inclusive sobrepor as curvas de cada uma dos tipos de profissionais e serviço de saúde com a da população. Iniciaremos com a curv da distribuição da população e acrescentamos as demais. gini(GoettingenHealth2$pop, lc = TRUE, lsize = 1, le.col = &quot;black&quot;, lc.col = &quot;orange&quot;, lcx = &quot;Participação dos distritos&quot;, lcy = &quot;Participação dos provedores&quot;, lctitle = &quot;Concentração espacial dos prestadores de serviços de saúde&quot;, lcg = TRUE, lcgn = TRUE, lcg.caption = &quot;População 2016:&quot;, lcg.lab.x = 0, lcg.lab.y = 1) ## [1] 0.5840336 gini(GoettingenHealth2$phys_gen, lc = TRUE, lsize = 1, add.lc = TRUE, lc.col = &quot;red&quot;, lcg = TRUE, lcgn = TRUE, lcg.caption = &quot;Clínicos gerais 2016:&quot;, lcg.lab.x = 0, lcg.lab.y = 0.85) ## [1] 0.8386269 gini(GoettingenHealth2$psych, lc = TRUE, lsize = 1, add.lc = TRUE, lc.col = &quot;blue&quot;, lcg = TRUE, lcgn = TRUE, lcg.caption = &quot;Psicólogos 2016:&quot;, lcg.lab.x = 0, lcg.lab.y = 0.7) ## [1] 0.9329298 Note que, pela aparência dos gráficos, conclui-se que eles são feitos utilizando ggplot2, que é chamado em plano de fundo pelo pacote REAT. Há diversos outros coeficientes de concentração e disperção no pacote REAT, os quais podem ser calculados de uma só vez por meio da função disp(). Os resultados podem demorar um pouco a serem exibidos devido a quantidade de coeficientes que serão calculados. Note também que informar o parâmetro weighting é uma vantagem, pois o output será mais completo. disp(GoettingenHealth2[,c(5,6,7)], weighting = GoettingenHealth2$pop) ## Concentration and dispersion measures ## Note: w = weighted, n = normalized, eq = equivalent number ## ## phys_gen psych pharm ## Gini 0.838626907 0.932929782 0.891547619 ## Gini n 0.840628403 0.935156345 0.893675418 ## Gini w 0.629454516 0.770895945 0.705628058 ## Gini w n 0.630956794 0.772735792 0.707312135 ## HHI 0.015280527 0.038494685 0.024166667 ## HHI n 0.012930361 0.036199923 0.021837709 ## HHI eq 65.442769020 25.977611940 41.379310345 ## Hoover 0.721428571 0.883333333 0.838095238 ## Hoover w 0.001852337 0.003130602 0.003418787 ## Theil NA NA NA ## Theil w NA NA NA ## Coulter 0.049850824 0.123305927 0.065569205 ## Atkinson 0.761164110 0.900755425 0.854223763 ## Dalton NA NA NA ## SD 1.714506606 1.095496987 0.865286915 ## SD w 4.010246439 1.847716870 2.401476794 ## CV 2.330397328 3.899226565 3.028504203 ## CV n 0.113847359 0.190489683 0.147952112 ## Williamson 1.429449565 1.965446423 1.709288672 5.1.3 Especialização regional e concentração espacial industrial Em todas as funções que calculam indicadores de especialização e concentração espacial seguem a seguinte base: \\(e_{ij}\\) é o nível de emprego na indústria \\(i\\) e região \\(j\\). Este valor é comparado a alguma referência, a qual pode ser o nível geral de emprego na região \\(j\\), \\(e_j\\) e/ou o nível geral de emprego na indústria \\(i\\), \\(e_i\\). Todas as funções que realizam este tipo de cálculo no pacote REAT requerem, então, pelo menos as informações sobre o nível de emprego em uma ou mais regiões \\(j\\) em uma ou mais indústrias \\(i\\), \\(e_{ij}\\) 5.1.3.1 Aplicação Vamos analisar a especialização regional da cidade de Göttingen, utilizando os dados contidos no dataset Goettingen. Este data frame apresenta a quantidade de empregos entre 2008 e 2017 em cada uma das indústrias elencadas de A a R (linhas de 2 a 16), sendo que a linha 1 contém o nível geral de emprego em determinado ano, considerando todas as indústrias. Vejamos antes a tabela de classificações de ativadades econômicas alemãs no ano de 2008 (WZ 2008): Código Atividade A Agriculture, forestry and fishing B Mining and quarrying C Manufacturing D Electricity, gas, steam and air conditioning supply E Water supply; sewerage, waste management and remediation activities F Construction G Wholesale and retail trade; repair of motor vehicles and motorcycles H Transportation and storage I Accommodation and food service activities J Information and communication K Financial and insurance activities L Real estate activities M Professional, scientific and technical activities N Administrative and support service activities O Public administration and defence; compulsory social security P Education Q Human health and social work activities R Arts, entertainment and recreation S Other service activities T Activities of households as employers; undifferentiated goods-and services-producing activities of households for own use U Activities of extraterritorial organisations and bodies Vamos carregar o dataset e verificar sua estrutura. data(Goettingen) str(Goettingen) ## tibble [16 × 22] (S3: tbl_df/tbl/data.frame) ## $ WZ2008_Code : chr [1:16] &quot;A-R&quot; &quot;A&quot; &quot;BDE&quot; &quot;C&quot; ... ## $ WZ2008_Name : chr [1:16] &quot;A-R Insgesamt&quot; &quot;A Land- und Forstwirtschaft, Fischerei&quot; &quot;B+D+E Bergbau, Energie, Wasser&quot; &quot;C Verarbeitendes Gewerbe&quot; ... ## $ Goettingen2008: num [1:16] 59125 44 446 9116 1611 ... ## $ Goettingen2009: num [1:16] 59201 39 466 8978 1562 ... ## $ Goettingen2010: num [1:16] 61524 45 452 9044 1575 ... ## $ Goettingen2011: num [1:16] 63538 48 458 8886 1575 ... ## $ Goettingen2012: num [1:16] 63643 47 484 8526 1506 ... ## $ Goettingen2013: num [1:16] 64351 45 508 8550 1522 ... ## $ Goettingen2014: num [1:16] 67212 41 495 8372 1308 ... ## $ Goettingen2015: num [1:16] 67137 43 490 8268 1192 ... ## $ Goettingen2016: num [1:16] 67818 41 475 7999 1356 ... ## $ Goettingen2017: num [1:16] 69403 45 466 7874 1334 ... ## $ BRD2008 : num [1:16] 27695398 215570 545874 6528569 1569359 ... ## $ BRD2009 : num [1:16] 27603281 218548 549648 6363086 1570440 ... ## $ BRD2010 : num [1:16] 27966601 220753 552291 6256701 1604017 ... ## $ BRD2011 : num [1:16] 28643583 226043 546277 6395463 1637168 ... ## $ BRD2012 : num [1:16] 29280034 231109 551263 6519169 1663477 ... ## $ BRD2013 : num [1:16] 29615680 236862 547782 6544148 1671811 ... ## $ BRD2014 : num [1:16] 30174505 244677 543076 6613194 1697305 ... ## $ BRD2015 : num [1:16] 30771297 247538 536566 6666275 1711831 ... ## $ BRD2016 : num [1:16] 31443318 246467 535808 6725261 1748807 ... ## $ BRD2017 : num [1:16] 32164973 248052 538768 6797172 1798954 ... As colunas começando no padrão GoettingerANO referem-se aos empregos na indústria, em cada nível de atividade econômica, na cidade de Göttingen no referido ano, ao passo que as colunas no padrão BRDANO, indicam os empregos na indústria, em cada nível de atividade econômica, para a Alemanha. Começaremos calculando o Coeficiente de Locação (LQ) para a cidade de Göttingen em 2017 com relação a indústria de manufaturados (_“Verarbeitendes Gewerbe”), representada pela letra C (linha 4), conforme a tabela de atividades econômicas alemã: Para isso, utilizamos a função locq(). locq(Goettingen$Goettingen2017[4], Goettingen$Goettingen2017[1], Goettingen$BRD2017[4], Goettingen$BRD2017[1]) ## [1] 0.5368737 O output apresenta o o coeficiente de locação \\(LQ_{ij}\\) para 2017, onde \\(i\\) é a indústria de manufatura e \\(j\\) é a cidade de Göttingen. Nota-se que o valor é bastante baixo, indicando que a indústria de manufatura tem pouca representatividade na economia de Göttingen, em comparação com a economia alemã. A seguir, calculamos o LQ para todas as indústrias (A-R, linhas de 2 a 16) no ano de 2017, incluindo um plot simples (argumento plot.results=TRUE). locq(Goettingen$Goettingen2017[2:16], Goettingen$Goettingen2017[1], Goettingen$BRD2017[2:16], Goettingen$BRD2017[1], industry.names = Goettingen$WZ2008_Code[2:16], plot.results = TRUE, plot.title = &quot;Quocientes de Locação para Göttingen 2017&quot;) ## Location quotients ## I = 15 industries ## LQ ## A 0.08407652 ## BDE 0.40085663 ## C 0.53687366 ## F 0.34366928 ## G 0.74603541 ## H 0.67117311 ## I 0.98141916 ## J 0.91654277 ## K 0.82650178 ## M 1.53027645 ## N 0.95843423 ## O 1.03509027 ## P 2.77790858 ## Q 1.67459967 ## R 0.35317012 Para medir o nível de especialização industrial de Göttingen utilizando um indicador único, podemos utilizar o coeficiente de Herfindahl-Hirschman herf(), calculando-o separadamente para Göttingen e para a economia Alemã. # Göttingen herf(Goettingen$Goettingen2017[2:16]) ## [1] 0.127314 # Alemanha herf(Goettingen$BRD2017[2:16]) ## [1] 0.1104567 Outras alternativas para se medir o nível de especialização regional são o coeficiente de especialização de Hoover hoover(), e os coeficientes de especialização regional de Gini gini.spec() e de Krugman krugman.spec(), todos utilizando como referência ref os dados da economia alemã na mesma seleção de atividades econômicas. hoover(Goettingen$Goettingen2017[2:16], ref = Goettingen$BRD2017[2:16]) ## [1] 0.2254234 gini.spec(Goettingen$Goettingen2017[2:16], Goettingen$BRD2017[2:16]) ## [1] 0.359852 krugman.spec(Goettingen$Goettingen2017[2:16], Goettingen$BRD2017[2:16]) ## [1] 0.4508469 5.1.4 Crescimento regional: anpalise shift-share Os modelos shift-share permitem decompor o crescimento regional em componentes, reconhecendo que regiões econômicas estão circunstcritas e são influenciadas por um sitema regional maior, que normalmente é a própria economia nacional. Dessa forma, o crescimento da indústria \\(i\\) n região \\(j\\) do tempo \\(t\\) atpe \\(t + y\\) pode ser atribuído a: uma tendência nacional (soma dos crescimentos regionais): national share crescimento ou declínio das indústrias consideradas na análise: industrial mix performance indústria-específica na região devido a vantagens/desvantagens locacionais: regional share (ou resíduo dos dois primeiros componentes) O pacote REAT abrange diversos modelos diferentes de análise shift-share: padrão shift(); dinâmico shiftd(); indústria-específico shifti(); indústria-específico e dinâmica shiftid(); prognóstico shiftp(). Todas as funções para análise shift-share (com exceção de prognóstico shift-share shiftp()) no pacote REAT provém 3 variantes para cálculo dos componentes: método clássico de Dunn, que é o defualt (shift.method=\"Dunn\"); extensão de Dunn (shift.method=\"Esteban\"), que produz 4 componentes e não 3; método de Gerfin (shift.method=\"Gerfin\"). 5.1.5 Aplicação Vamos novamente utilizar o dataset Goettingen, contendo os dados de emprego por setor de atividade econômica na cidade de Göttingen e na Alemanha entre 2008 e 2017. A análise shift-share nos permitirá decompor o crescimento do emprego nos componentes nacional, industrial e regional. Inicialmente, faremos uma análise estática (método clássico de Dunn) aplicando a função shift(): shift(Goettingen$Goettingen2008[2:16], Goettingen$Goettingen2017[2:16], Goettingen$BRD2008[2:16], Goettingen$BRD2017[2:16]) ## ## Shift-Share Analysis ## Method: Dunn ## ## Shift-share components ## Components ## Growth (t1-t) 10411.0000 ## National share 9178.1916 ## Industrial mix 2204.8202 ## Regional share -972.0118 ## Net total shift 1232.8084 ## ## Calculation for 15 industries ## Regional employment at time t: 56872, at time t+1: 67283 (10411 / 18.30602 %) ## National employment at time t: 27695398, at time t+1: 32164973 (4469575 / 16.13833 %) Nessa análise transversal, nota-se que o emprego em Göttingen cresceu em 10.411 pessoas entre 2008 e 2017. No entanto, nota-se que a maior parte desse crescimento deve-se ao componente nacional, que apresentou valor pouco menor que o da cidade. O regional share apresenta valor negativo, indicando desvantagens locacionais. O valor de industrial mix pode ser atribuído a uma sobrerepresentação de indústrias em crescimento na cidade segundo Wieland (2019). Os resultados são corroborados pelo método de Gerfin: shift(Goettingen$Goettingen2008[2:16], Goettingen$Goettingen2017[2:16], Goettingen$BRD2008[2:16], Goettingen$BRD2017[2:16], shift.method = &quot;Gerfin&quot;) ## ## Shift-Share Analysis ## Method: Gerfin ## ## Shift-share components ## Components ## Industrial mix 1.0333810 ## Regional share 0.9857591 ## Net total shift 1.0186647 ## ## Calculation for 15 industries ## Regional employment at time t: 56872, at time t+1: 67283 (10411 / 18.30602 %) ## National employment at time t: 27695398, at time t+1: 32164973 (4469575 / 16.13833 %) Os métodos anteriores somente consideram o crescimento geral em relação aos dados em carater transversal, sem considerar a particularidade de cada setor. Para detalhar os dados por indústria e considerar também efeitos sazonais entre os períodos, utiliza-se o modelo dinâmico e indústria específico shiftid(). Para isso, nós precisaremos de dados para o período inicial time1 e pelo menos para dois períodos seguintes time2. Uma outra diferença da função shiftid() é que podemos informar os nomes dos setores industriais no arumento industry.names, já que a análise é indústria-específica. # Cuidado! # transformar em data frame antes (bug do pacote - nao aceita tibble) Goettingen &lt;- as.data.frame(Goettingen, stringsASFactors = FALSE) shiftid(Goettingen$Goettingen2008[2:16], Goettingen[2:16, 3:12], Goettingen$BRD2008[2:16], Goettingen[2:16, 13:22], time1 = 2008, time2 = 2017, industry.names = Goettingen$WZ2008_Code[2:16]) ## ## Dynamic Shift-Share Analysis ## Method: Dunn ## ## Shift-share components ## A BDE C F G H I J K ## Growth (t1-t) -3.000000 29.00000 -1117.0000 -255.0000 -51.0000 524.0000 470.00000 274.00000 -465.000000 ## National share 6.103502 -9.46377 254.5217 160.0638 561.7436 368.2053 515.03493 286.32383 6.356612 ## Regional share -9.103502 38.46377 -1371.5217 -415.0638 -612.7436 155.7947 -45.03493 -12.32383 -471.356612 ## Net total shift -9.103502 38.46377 -1371.5217 -415.0638 -612.7436 155.7947 -45.03493 -12.32383 -471.356612 ## M N O P Q R ## Growth (t1-t) 2229.000 1178.0000 268.0000 1272.0000 4211.000 363.00000 ## National share 1821.392 977.9869 167.9118 1138.5383 3556.692 47.50353 ## Regional share 407.608 200.0131 100.0882 133.4617 654.308 315.49647 ## Net total shift 407.608 200.0131 100.0882 133.4617 654.308 315.49647 ## ## Calculation for 15 industries ## Regional employment at time t: 56872, at time t+1: 67283 (10411 / 18.30602 %) ## National employment at time t: 27695398, at time t+1: 32164973 (4469575 / 16.13833 %) 5.1.6 Referências da seção Wieland, T. (2019). REAT: A Regional Economic Analysis Toolbox for R. REGION, 6(3), 2019, R1-R57. URL https://doi.org/10.18335/region.v6i3.267. Disponível em: https://openjournals.wu-wien.ac.at/region/paper_267/267.html Hoffman, R. (1998). Distribuição de renda: medidas de desigualdade e pobreza. São Paulo: Editora da Universidade de São Paulo, 1998. "],["conclusão.html", "Conclusão", " Conclusão Embora o curso seja introdutório, acredito que você pôde alcançar um nível de fluência em R que terá um impacto significativo em seu trabalho. Passamos por tópicos básicos sobre o funcionamento da linguagem, seus principais objetos, ferramentas para a análise de dados e seguimos até o tema da reproducibilidade, finalizando com uma aplicação de modelos de análise econômica regional em R. Ao longo deste caminho, você teve contato com excelentes pacotes e técnicas que facilitarão muito o seu trabalho no que se refere à análise de dados. A partir de agora, você encontra-se pronto para seguir de forma mais independente no caminho de desenvolver soluções em Análise de Dados utilizando o R. Seu nível de proficiência agora lhe permite pensar melhor sobre a organização dos seus dados, que tipo de problema você possui, qual a melhor forma de abordá-lo e o principal: como e onde procurar ajuda para resolvê-lo. Aproveite o excelente material que você possui em mãos e retorne a ele e às referências sempre que precisar. Obrigado pela companhia ao longo desta jornada! Allan V. C. Quadros "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
